<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pinball CTL Docs</title>
  <meta name="description" content="Pinball CTL documentation site.">
  <link rel="stylesheet" href="./assets/css/style.css">
  <link rel="stylesheet" href="./assets/css/docs.css">
</head>
<body>
  <header class="site-header">
    <a class="brand" href="#doc=README" aria-label="Pinball CTL docs home">
      <span class="brand-dot" aria-hidden="true"></span>
      <span>Pinball CTL Docs</span>
    </a>
    <button class="menu-toggle" type="button" aria-expanded="false" aria-label="Toggle navigation">
      <span></span><span></span><span></span>
    </button>
    <nav class="site-nav" aria-label="Main navigation">
      <span class="docs-updated">Updated 2026-02-18 08:19 UTC</span>
      <a href="https://pinballctl.com" class="nav-link website-link">
        <svg class="website-link__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M3 12h18M12 3a16 16 0 0 1 0 18M12 3a16 16 0 0 0 0 18M4.5 7.5h15M4.5 16.5h15"/>
        </svg>
        <span>Pinball CTL Website</span>
      </a>
    </nav>
  </header>

  <main id="top" class="docs-shell">
    <section class="section">
      <p class="kicker hero-kicker">Documentation</p>
      <h1>Pinball CTL Documentation</h1>
      <p class="lead">Find setup guides, feature walkthroughs, and troubleshooting help for Pinball CTL.</p>

      <div class="docs-toolbar">
        <button id="docs-sidebar-toggle" class="docs-sidebar-toggle" type="button" aria-expanded="false" aria-controls="docs-sidebar">Docs Menu</button>
        <input type="search" id="docs-search" data-docs-search="desktop" class="docs-search-input docs-search-desktop" placeholder="Search docs..." />
        <span id="docs-search-status" data-docs-search-status="desktop" class="docs-search-status docs-search-status-desktop"></span>
      </div>

      <div class="docs-layout">
        <aside id="docs-sidebar" class="docs-sidebar">
          <div class="docs-sidebar-head">
            <span class="docs-sidebar-title">Docs Menu</span>
            <button id="docs-sidebar-close" class="docs-sidebar-close" type="button" aria-label="Close docs menu">Close</button>
          </div>
          <div class="docs-sidebar-search">
            <input type="search" id="docs-search-mobile" data-docs-search="mobile" class="docs-search-input" placeholder="Search docs..." />
            <span id="docs-search-status-mobile" data-docs-search-status="mobile" class="docs-search-status"></span>
          </div>
          <div id="docs-bookmarks-wrap" class="docs-bookmarks-wrap hidden">
            <div class="docs-bookmarks-title">Bookmarks</div>
            <div id="docs-bookmarks" class="docs-bookmarks"></div>
          </div>
          <div id="docs-tree" class="docs-tree"></div>
          <div id="docs-search-results" class="docs-search-results hidden"></div>
        </aside>

        <article class="docs-content">
          <button id="docs-bookmark-toggle" class="docs-bookmark-toggle docs-bookmark-toggle-card" type="button" aria-pressed="false" aria-label="Bookmark current page" title="Bookmark current page">
            <svg class="docs-bookmark-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M7 3h10a1 1 0 0 1 1 1v17l-6-3.8L6 21V4a1 1 0 0 1 1-1z"></path>
            </svg>
          </button>
          <div class="doc-panel" id="docs-article"></div>
        </article>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="site-footer__inner">
      <p class="site-footer__copy">&copy; 2026 Pinball CTL. All rights reserved.</p>
      <nav class="site-footer__nav" aria-label="Footer links">
        <a href="https://www.pinballctl.com/privacy.html" target="_blank" rel="noopener noreferrer">Privacy</a>
        <a href="https://www.pinballctl.com/terms.html" target="_blank" rel="noopener noreferrer">Terms</a>
        <a href="https://www.pinballctl.com/contact.html" target="_blank" rel="noopener noreferrer">Contact</a>
      </nav>
    </div>
  </footer>

  <div id="img-modal" class="img-modal" aria-hidden="true" role="dialog" aria-label="Screenshot preview">
    <div class="img-modal__backdrop"></div>
    <div class="img-modal__body">
      <button class="img-modal__close" aria-label="Close preview">Close</button>
      <img src="" alt="Screenshot preview" class="img-modal__img">
    </div>
  </div>

  <script id="site-data-inline" type="application/json">{"generated_at":"2026-02-18T08:19:35.441285+00:00","default_slug":"README","tree":[{"type":"page","title":"Pinball CTL Manual","slug":"README","order":10000},{"type":"folder","name":"User Guide","path":"1-user-guide","children":[{"type":"page","title":"Getting Started","slug":"1-user-guide/1-getting-started","order":1},{"type":"page","title":"Interface Tour","slug":"1-user-guide/2-interface","order":2},{"type":"page","title":"Features","slug":"1-user-guide/3-featured","order":3},{"type":"page","title":"Dashboard","slug":"1-user-guide/5-dashboard","order":5},{"type":"page","title":"Rules","slug":"1-user-guide/7-rules","order":7},{"type":"page","title":"Scoring","slug":"1-user-guide/7.1-scoring","order":7},{"type":"page","title":"Lighting","slug":"1-user-guide/8-lighting","order":8},{"type":"page","title":"Playfield","slug":"1-user-guide/9-layout","order":9},{"type":"page","title":"Hardware","slug":"1-user-guide/10-hardware","order":10},{"type":"page","title":"ESPLink","slug":"1-user-guide/11-esplink","order":11},{"type":"page","title":"Firmware","slug":"1-user-guide/12-firmware","order":12},{"type":"page","title":"Service Log","slug":"1-user-guide/13-service-log","order":13},{"type":"page","title":"Logs","slug":"1-user-guide/14-logs","order":14},{"type":"page","title":"Wi Fi","slug":"1-user-guide/15-wifi","order":15},{"type":"page","title":"Settings","slug":"1-user-guide/16-settings","order":16},{"type":"page","title":"Audio","slug":"1-user-guide/17-audio","order":17},{"type":"page","title":"Media","slug":"1-user-guide/18-media","order":18},{"type":"page","title":"Supported Components","slug":"1-user-guide/99-supported-components","order":99}]},{"type":"folder","name":"Technical Notes","path":"2-technical-notes","children":[{"type":"page","title":"Technical Section","slug":"2-technical-notes/README","order":10000},{"type":"page","title":"Bridge Event Flow And Throughput","slug":"2-technical-notes/bridge-event-flow-and-throughput","order":10000},{"type":"page","title":"Bridge Protocol","slug":"2-technical-notes/bridge-protocol","order":10000},{"type":"page","title":"Event Manager Entry Points (Requirement + Implementation)","slug":"2-technical-notes/event-manager-entry-points","order":10000},{"type":"page","title":"Pi Event Manager: Handlers and Current State","slug":"2-technical-notes/event-manager-handlers-and-current-state","order":10000},{"type":"page","title":"Technical Architecture","slug":"2-technical-notes/architecture","order":10000},{"type":"folder","name":"From App Docs","path":"2-technical-notes/from-app-docs","children":[{"type":"page","title":"In the project root:","slug":"2-technical-notes/from-app-docs/PACKAGING","order":10000},{"type":"page","title":"Running pinballctl","slug":"2-technical-notes/from-app-docs/RUNNING","order":10000},{"type":"page","title":"SYSTEM","slug":"2-technical-notes/from-app-docs/SYSTEM","order":10000}]},{"type":"folder","name":"Modules","path":"2-technical-notes/modules","children":[{"type":"page","title":"Technical Module Reference","slug":"2-technical-notes/modules/README","order":10000},{"type":"page","title":"Dashboard Module","slug":"2-technical-notes/modules/dashboard","order":10000},{"type":"page","title":"ESPLink Module","slug":"2-technical-notes/modules/esplink","order":10000},{"type":"page","title":"Events API Module (Internal)","slug":"2-technical-notes/modules/events-api","order":10000},{"type":"page","title":"Firmware Module","slug":"2-technical-notes/modules/firmware","order":10000},{"type":"page","title":"Hardware Module","slug":"2-technical-notes/modules/hardware","order":10000},{"type":"page","title":"Layout (Playfield) Module","slug":"2-technical-notes/modules/playfield","order":10000},{"type":"page","title":"Logs Module","slug":"2-technical-notes/modules/logs","order":10000},{"type":"page","title":"Rules Module","slug":"2-technical-notes/modules/rules","order":10000},{"type":"page","title":"Service Log Module","slug":"2-technical-notes/modules/service-log","order":10000},{"type":"page","title":"Settings Module","slug":"2-technical-notes/modules/settings","order":10000},{"type":"page","title":"Wi Fi Module","slug":"2-technical-notes/modules/wifi","order":10000}]},{"type":"folder","name":"Specifications","path":"2-technical-notes/specifications","children":[{"type":"page","title":"Technical Discussions","slug":"2-technical-notes/specifications/README","order":10000},{"type":"page","title":"Emulator","slug":"2-technical-notes/specifications/EMULATOR","order":10000},{"type":"page","title":"ESPLink — Module Specification","slug":"2-technical-notes/specifications/ESPLink","order":10000},{"type":"page","title":"In the project root:","slug":"2-technical-notes/specifications/PACKAGING","order":10000},{"type":"page","title":"Lighting Module – Technical Specification (Draft)","slug":"2-technical-notes/specifications/LIGHTING","order":10000},{"type":"page","title":"MAINTAINER GUIDE — pinballctl","slug":"2-technical-notes/specifications/MAINTAINER","order":10000},{"type":"page","title":"Pinball Event to Action Engine","slug":"2-technical-notes/specifications/EVENT_ENGINE","order":10000},{"type":"page","title":"RULIES (Imported)","slug":"2-technical-notes/specifications/RULIES","order":10000},{"type":"page","title":"Running pinballctl","slug":"2-technical-notes/specifications/RUNNING","order":10000},{"type":"page","title":"SYSTEM CONTEXT","slug":"2-technical-notes/specifications/SYSTEM_CONTEXT","order":10000}]}]}],"pages":[{"slug":"1-user-guide/1-getting-started","path":"1-user-guide/1-getting-started.md","title":"Getting Started","order":1,"html":"<h1>Getting Started</h1><p>This guide helps you get Pinball CTL running from a clean Raspberry Pi setup.</p><p>It is written for real-world first installs, not just developer machines.</p><h2>Before You Start</h2><p>Pinball CTL is under active development. It runs well on the hardware used in this project, but it has not yet been broadly tested across all Raspberry Pi and peripheral combinations.</p><p>In plain terms: if your setup is different, your mileage may vary.</p><h2>Requirements</h2><p>The table below shows what is required and what has been tested in this project.</p><div class=\"manual-table-wrap\">  <table class=\"manual-table manual-requirements-table\">    <thead>      <tr>        <th>Item</th>        <th>Required</th>        <th>Tested</th>        <th>Notes</th>      </tr>    </thead>    <tbody>      <tr><td>Raspberry Pi 5</td><td>✅</td><td>✅</td><td>Main target platform</td></tr>      <tr><td>ESP32-S3 controller board</td><td>✅</td><td>✅</td><td>Real-time I/O and safety layer</td></tr>      <tr><td>microSD card (32GB recommended)</td><td>✅</td><td>✅</td><td>Raspberry Pi OS and local storage</td></tr>      <tr><td>Stable Pi power supply</td><td>✅</td><td>✅</td><td>Use a suitable PSU for Pi 5</td></tr>      <tr><td>USB data cable (Pi &lt;-&gt; ESP32-S3)</td><td>✅</td><td>✅</td><td>Must be a data cable, not charge-only</td></tr>      <tr><td>Network connection (Ethernet or Wi-Fi)</td><td>✅</td><td>✅</td><td>Needed for package install and web UI access</td></tr>      <tr><td>Raspberry Pi OS 64-bit</td><td>✅</td><td>✅</td><td>Recommended by Raspberry Pi for Pi 5</td></tr>      <tr><td>Python 3.11+</td><td>✅</td><td>✅</td><td>Required by Pinball CTL</td></tr>      <tr><td><code>python3-venv</code></td><td>✅</td><td>✅</td><td>For isolated environment install</td></tr>      <tr><td><code>pip</code></td><td>✅</td><td>✅</td><td>Package installation</td></tr>      <tr><td><code>git</code></td><td>⚠️ If installing from Git URL</td><td>✅</td><td>Needed for tag-based Git install</td></tr>      <tr><td>macOS dev machine</td><td>❌</td><td>✅</td><td>Development was done on macOS; runtime target is Pi</td></tr>      <tr><td>Web browser (Chrome, Edge, Safari, Firefox)</td><td>✅</td><td>✅</td><td>For Pinball CTL web interface</td></tr>    </tbody>  </table></div><p>For hardware-specific status, see:</p><ul><li><a href=\"#doc=1-user-guide/99-supported-components\">Supported Components</a></li></ul><h2>Prepare Raspberry Pi OS</h2><p>Start with a clean Raspberry Pi OS image and flash it to your SD card.</p><p>Official Raspberry Pi references:</p><ul><li><a href=\"https://www.raspberrypi.com/software/\">Raspberry Pi Imager</a></li><li><a href=\"https://www.raspberrypi.com/documentation/installation/installing-images/\">Install an operating system</a></li><li><a href=\"https://www.raspberrypi.com/software/operating-systems/\">Raspberry Pi OS downloads</a></li></ul><p>Recommended for Pi 5:</p><ul><li>Use the current recommended <strong>Raspberry Pi OS (64-bit)</strong> entry in Raspberry Pi Imager.</li><li>As of <strong>4 December 2025</strong>, Raspberry Pi lists Raspberry Pi OS 64-bit based on Debian 13 (Trixie) for Pi 5.</li></ul><p>Tip:</p><ul><li>Raspberry Pi Imager is the quickest way to get started for most users.</li><li>In Raspberry Pi Imager, open OS customisation before writing the card.</li><li>Preconfigure Wi-Fi, username/password, locale, and SSH so these settings are baked into the image for easier remote setup.</li></ul><h2>Boot and Connect to the Pi</h2><p>You can continue setup in either of these ways:</p><ol><li>SSH from another machine (recommended for headless setups).</li><li>Directly on the Pi using keyboard + monitor.</li></ol><h3>Option A: SSH</h3><p>If SSH was enabled in Imager:</p><pre><code>ssh &lt;your-user&gt;@raspberrypi.local</code></pre><p>If mDNS is not available on your network, use the Pi IP address instead:</p><pre><code>ssh &lt;your-user&gt;@&lt;pi-ip-address&gt;</code></pre><h3>Option B: Keyboard + Monitor</h3><p>Log in locally and open Terminal.</p><h2>Install Pinball CTL in a Virtual Environment</h2><p>Run the following on your Pi.</p><h3>Install base tools</h3><pre><code>sudo apt update\nsudo apt install -y python3-venv python3-pip git</code></pre><h3>Create and activate a venv</h3><pre><code>mkdir -p ~/pinballctl\ncd ~/pinballctl\npython3 -m venv .venv\nsource .venv/bin/activate\npython -m pip install --upgrade pip</code></pre><h3>Install from a Git tag (recommended)</h3><p>If you know the release tag:</p><pre><code>python -m pip install &quot;git+https://github.com/VineCode/pinballctl.git@vX.Y.Z&quot;</code></pre><p>If you want to resolve and install the latest tag automatically:</p><pre><code>REPO_URL=&quot;https://github.com/VineCode/pinballctl.git&quot;\nLATEST_TAG=&quot;$(git ls-remote --refs --sort=&#x27;version:refname&#x27; --tags &quot;$REPO_URL&quot; | tail -n1 | sed &#x27;s|.*refs/tags/||&#x27;)&quot;\npython -m pip install &quot;git+$REPO_URL@$LATEST_TAG&quot;</code></pre><p>Then verify:</p><pre><code>pinballctl --version</code></pre><p>Note:</p><ul><li>Packaging in this project is wheel-based (see release/build scripts and <code>pyproject.toml</code>).</li><li>Installing from a tag gives you a reproducible version aligned to a release point.</li></ul><h2>Run Pinball CTL</h2><p>For most users, this is all you need:</p><pre><code>pinballctl start</code></pre><p>This starts Pinball CTL with the default runtime setup.</p><p>You can check status at any time:</p><pre><code>pinballctl status</code></pre><p>Advanced:</p><ul><li>If you need manual control of individual services and options, use:</li></ul><pre><code>pinballctl --help</code></pre><h2>Open the Web Interface</h2><p>From a browser on your network, open:</p><pre><code>http://&lt;pi-ip-address&gt;:8888</code></pre><p>If local hostname resolution works on your network, this may also work:</p><pre><code>http://raspberrypi.local:8888</code></pre><p>You should see the Pinball CTL login screen in your browser:</p><img src=\"./media/screenshot-login.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true}' alt=\"Pinball CTL login screen\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Default login credentials:</p><ul><li>Username: <code>admin</code></li><li>Password: <code>password</code></li></ul><p>For safety, change the default password as soon as you log in.</p><h2>Optional: Run as Services</h2><p>For auto-start on boot and easier long-running use:</p><pre><code>pinballctl service install\npinballctl service start all\npinballctl status</code></pre><h2>Command Overview</h2><p>Use <code>pinballctl --help</code> at any time for the full command tree.</p><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Command</th>        <th>What it does</th>      </tr>    </thead>    <tbody>      <tr><td><code>pinballctl start</code></td><td>Starts Pinball CTL with the default runtime setup</td></tr>      <tr><td><code>pinballctl status</code></td><td>Shows system, service, network, and port status</td></tr>      <tr><td><code>pinballctl --version</code></td><td>Shows installed Pinball CTL version</td></tr>      <tr><td><code>pinballctl --help</code></td><td>Shows top-level help</td></tr>      <tr><td><code>pinballctl web --help</code></td><td>Shows web command options</td></tr>      <tr><td><code>pinballctl bridge --help</code></td><td>Shows bridge command options</td></tr>      <tr><td><code>pinballctl service install</code></td><td>Installs and enables systemd services</td></tr>      <tr><td><code>pinballctl service start all</code></td><td>Starts web + bridge services</td></tr>      <tr><td><code>pinballctl service restart all</code></td><td>Restarts all services</td></tr>      <tr><td><code>pinballctl service --help</code></td><td>Shows service command options</td></tr>    </tbody>  </table></div><h2>Troubleshooting Quick Checks</h2><p>If something is not working, check these first:</p><ol><li>Is your venv active (<code>source .venv/bin/activate</code>)?</li><li>Does <code>pinballctl --version</code> work?</li><li>Is the web app running on port 8888?</li><li>Is your Pi reachable on the network?</li></ol>","plain":"Getting Started This guide helps you get Pinball CTL running from a clean Raspberry Pi setup. It is written for real-world first installs, not just developer machines. Before You Start Pinball CTL is under active development. It runs well on the hardware used in this project, but it has not yet been broadly tested across all Raspberry Pi and peripheral combinations. In plain terms: if your setup is different, your mileage may vary. Requirements The table below shows what is required and what has been tested in this project. Item Required Tested Notes Raspberry Pi 5 ✅ ✅ Main target platform ESP32-S3 controller board ✅ ✅ Real-time I/O and safety layer microSD card 32GB recommended ✅ ✅ Raspberry Pi OS and local storage Stable Pi power supply ✅ ✅ Use a suitable PSU for Pi 5 USB data cable Pi &lt;-&gt; ESP32-S3 ✅ ✅ Must be a data cable, not charge-only Network connection Ethernet or Wi-Fi ✅ ✅ Needed for package install and web UI access Raspberry Pi OS 64-bit ✅ ✅ Recommended by Raspberry Pi for Pi 5 Python 3.11+ ✅ ✅ Required by Pinball CTL python3-venv ✅ ✅ For isolated environment install pip ✅ ✅ Package installation git ⚠️ If installing from Git URL ✅ Needed for tag-based Git install macOS dev machine ❌ ✅ Development was done on macOS; runtime target is Pi Web browser Chrome, Edge, Safari, Firefox ✅ ✅ For Pinball CTL web interface For hardware-specific status, see: Supported Components Prepare Raspberry Pi OS Start with a clean Raspberry Pi OS image and flash it to your SD card. Official Raspberry Pi references: Raspberry Pi Imager Install an operating system Raspberry Pi OS downloads Recommended for Pi 5: Use the current recommended Raspberry Pi OS 64-bit entry in Raspberry Pi Imager. As of 4 December 2025, Raspberry Pi lists Raspberry Pi OS 64-bit based on Debian 13 Trixie for Pi 5. Tip: Raspberry Pi Imager is the quickest way to get started for most users. In Raspberry Pi Imager, open OS customisation before writing the card. Preconfigure Wi-Fi, username/password, locale, and SSH so these settings are baked into the image for easier remote setup. Boot and Connect to the Pi You can continue setup in either of these ways: SSH from another machine recommended for headless setups . Directly on the Pi using keyboard + monitor. Option A: SSH If SSH was enabled in Imager: If mDNS is not available on your network, use the Pi IP address instead: Option B: Keyboard + Monitor Log in locally and open Terminal. Install Pinball CTL in a Virtual Environment Run the following on your Pi. Install base tools Create and activate a venv Install from a Git tag recommended If you know the release tag: If you want to resolve and install the latest tag automatically: Then verify: Note: Packaging in this project is wheel-based see release/build scripts and pyproject.toml . Installing from a tag gives you a reproducible version aligned to a release point. Run Pinball CTL For most users, this is all you need: This starts Pinball CTL with the default runtime setup. You can check status at any time: Advanced: If you need manual control of individual services and options, use: Open the Web Interface From a browser on your network, open: If local hostname resolution works on your network, this may also work: You should see the Pinball CTL login screen in your browser: Default login credentials: Username: admin Password: password For safety, change the default password as soon as you log in. Optional: Run as Services For auto-start on boot and easier long-running use: Command Overview Use pinballctl --help at any time for the full command tree. Command What it does pinballctl start Starts Pinball CTL with the default runtime setup pinballctl status Shows system, service, network, and port status pinballctl --version Shows installed Pinball CTL version pinballctl --help Shows top-level help pinballctl web --help Shows web command options pinballctl bridge --help Shows bridge command options pinballctl service install Installs and enables systemd services pinballctl service start all Starts web + bridge services pinballctl service restart all Restarts all services pinballctl service --help Shows service command options Troubleshooting Quick Checks If something is not working, check these first: Is your venv active source .venv/bin/activate ? Does pinballctl --version work? Is the web app running on port 8888? Is your Pi reachable on the network?","excerpt":"Getting Started This guide helps you get Pinball CTL running from a clean Raspberry Pi setup. It is written for real-world first installs, not just developer machines. Before You Start Pinball CTL is under active..."},{"slug":"1-user-guide/10-hardware","path":"1-user-guide/10-hardware.md","title":"Hardware","order":10,"html":"<h1>Hardware</h1><p>Hardware is the feature for physical I/O mapping and controller integration setup.</p><p>It manages pin-level mapping, safety defaults, friendly names, and function assignment.</p><img src=\"./media/screenshot-feature-hardware.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/hardware\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Hardware feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>Hardware defines machine I/O in a structured form used by:</p><ul><li>Rules trigger/action targeting</li><li>Lighting cast and fixture context</li><li>ESP deployment and runtime mapping</li></ul><h2>Top Controls</h2><ul><li><code>Reload Pins</code></li><li><code>Sync to ESP</code></li><li><code>Save Mapping</code></li></ul><p>Behaviour:</p><ul><li>unsaved changes show an <code>Unsaved changes</code> badge</li><li>save/sync flows include validation and progress states</li><li>sync may request save first when local edits are pending</li></ul><h2>Mapping Table Columns</h2><ul><li>UID</li><li>Board</li><li>Type</li><li>Notes</li><li>Channel</li><li>PIN State</li><li>PIN Safe</li><li>Friendly Name</li><li>Function</li></ul><p><code>Table Key</code> modal explains each column in plain language.</p><h2>Editing Fields</h2><h3>Friendly Name</h3><p>Editable for mappable pins. Used across UI labels and selectors.</p><h3>Function</h3><p>Select logical function used by runtime and authoring features.</p><h3>PIN Safe</h3><p>For eligible general GPIO pins, choose safe state:</p><ul><li>default</li><li>HIGH</li><li>LOW</li></ul><p>Applied for safe inactive/fault conditions.</p><h2>Show All Pins Toggle</h2><p><code>Show all Pins</code> displays normally-hidden reserved/limited pins.</p><p>Default view filters to safer, mappable pin rows.</p><h2>Save Mapping</h2><p><code>Save Mapping</code> writes local mapping configuration.</p><p>On success:</p><ul><li>dirty state clears</li><li>success toast/message is shown</li></ul><h2>Sync to ESP</h2><p>The Sync button indicates whether the configuration is in sync with the ESP.</p><ul><li>If mapping is not synced, the sync action shows a warning state (<code>Sync &lt;name&gt;</code> warning).</li><li>If mapping is synced, the sync action shows the blue disabled OK state.</li></ul><h2>Reload Pins</h2><p><code>Reload Pins</code> refreshes discovered pin set from ESP source.</p><p>Use when:</p><ul><li>firmware pin definitions changed</li><li>hardware board changed</li><li>UID/channel set needs refresh</li></ul><h2>Practical Setup Examples</h2><h3>Initial machine mapping</h3><ol><li>Reload Pins.</li><li>Name each relevant pin.</li><li>Assign function roles.</li><li>Save Mapping.</li><li>Sync to ESP.</li></ol><h3>Safety-first output setup</h3><p>For output-capable pins:</p><ul><li>set clear Friendly Name</li><li>assign correct output function</li><li>define PIN Safe state for boot/fault behaviour</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/11-esplink\">ESPLink</a></li><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/8-lighting\">Lighting</a></li></ul>","plain":"Hardware Hardware is the feature for physical I/O mapping and controller integration setup. It manages pin-level mapping, safety defaults, friendly names, and function assignment. What This Feature Does Hardware defines machine I/O in a structured form used by: Rules trigger/action targeting Lighting cast and fixture context ESP deployment and runtime mapping Top Controls Reload Pins Sync to ESP Save Mapping Behaviour: unsaved changes show an Unsaved changes badge save/sync flows include validation and progress states sync may request save first when local edits are pending Mapping Table Columns UID Board Type Notes Channel PIN State PIN Safe Friendly Name Function Table Key modal explains each column in plain language. Editing Fields Friendly Name Editable for mappable pins. Used across UI labels and selectors. Function Select logical function used by runtime and authoring features. PIN Safe For eligible general GPIO pins, choose safe state: default HIGH LOW Applied for safe inactive/fault conditions. Show All Pins Toggle Show all Pins displays normally-hidden reserved/limited pins. Default view filters to safer, mappable pin rows. Save Mapping Save Mapping writes local mapping configuration. On success: dirty state clears success toast/message is shown Sync to ESP The Sync button indicates whether the configuration is in sync with the ESP. If mapping is not synced, the sync action shows a warning state Sync warning . If mapping is synced, the sync action shows the blue disabled OK state. Reload Pins Reload Pins refreshes discovered pin set from ESP source. Use when: firmware pin definitions changed hardware board changed UID/channel set needs refresh Practical Setup Examples Initial machine mapping Reload Pins. Name each relevant pin. Assign function roles. Save Mapping. Sync to ESP. Safety-first output setup For output-capable pins: set clear Friendly Name assign correct output function define PIN Safe state for boot/fault behaviour Related Features ESPLink Rules Lighting","excerpt":"Hardware Hardware is the feature for physical I/O mapping and controller integration setup. It manages pin-level mapping, safety defaults, friendly names, and function assignment. What This Feature Does Hardware defines..."},{"slug":"1-user-guide/11-esplink","path":"1-user-guide/11-esplink.md","title":"ESPLink","order":11,"html":"<h1>ESPLink</h1><p>ESPLink manages Pi-to-ESP connectivity, bridge control, firmware apply flow, and runtime utility actions.</p><img src=\"./media/screenshot-feature-esplink.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/esplink\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"ESPLink feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>ESPLink provides the operational control layer between authored configuration and live ESP runtime.</p><p>Key responsibilities:</p><ul><li>device selection</li><li>bridge lifecycle control</li><li>status/identity visibility</li><li>utility actions (FS, echo, reboot)</li><li>applying downloaded firmware to connected ESP</li></ul><h2>Header Controls</h2><ul><li>device dropdown (<code>Select device…</code>)</li><li>connection status dot/text</li><li>firmware readout</li><li><code>Refresh</code></li><li><code>Reboot</code></li><li><code>Sync Time</code></li></ul><p>Button availability depends on selected/connected device state.</p><h2>No-Device State</h2><p>When no ESP devices are available, a dedicated card explains that USB connection is required.</p><h2>Overview Card</h2><p>Displays:</p><ul><li>Port</li><li>Chip</li><li>IP</li><li>RSSI</li></ul><p>Bridge section displays:</p><ul><li>Bridge Status</li><li>Bridge Port</li><li>Bridge Firmware</li><li>Bridge Chip</li></ul><p>Bridge actions:</p><ul><li><code>Start</code></li><li><code>Stop</code></li><li><code>Restart</code></li></ul><h2>Actions Card</h2><p>Operational tools:</p><ul><li><code>FS Status</code></li><li><code>List Files</code></li><li><code>Reboot ESP</code></li><li><code>Echo Test</code></li></ul><p>Each action opens a result modal.</p><p>Available result modals:</p><ul><li>FS Status modal</li><li>File List modal</li><li>Echo Test modal</li><li>Reboot ESP modal</li></ul><h2>Firmware Card (Local Apply)</h2><p>Purpose: apply locally downloaded firmware to connected ESP.</p><p>List behaviour:</p><ul><li>shows locally available versions</li><li>displays <code>Latest</code> and <code>Current</code> badges where relevant</li><li>apply action per version</li><li>upload console with progress/log output</li></ul><h2>Compatibility and Confidence Checks</h2><p>ESPLink helps ensure safe rollout by exposing:</p><ul><li>bridge running state</li><li>device presence</li><li>live firmware/chip info</li><li>clear checks that Pi and ESP are on matching versions and manifest data before deployment</li></ul><h2>Typical Workflow</h2><ol><li>Select target ESP device.</li><li>Confirm status dot and overview data.</li><li>Start/restart bridge if needed.</li><li>Use Sync Time and utility checks.</li><li>Apply firmware if required.</li><li>Continue with hardware/rules/lighting sync actions.</li></ol><h2>Practical Examples</h2><h3>Recovery after USB reconnect</h3><ul><li>press Refresh</li><li>if bridge stopped, Start bridge</li><li>verify chip/firmware visible again</li></ul><h3>Pre-sync validation</h3><ul><li>ensure connected status is green</li><li>run Echo Test quickly</li><li>check FS/list outputs if needed</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li><li><a href=\"#doc=1-user-guide/12-firmware\">Firmware</a></li><li><a href=\"#doc=1-user-guide/14-logs\">Logs</a></li></ul>","plain":"ESPLink ESPLink manages Pi-to-ESP connectivity, bridge control, firmware apply flow, and runtime utility actions. What This Feature Does ESPLink provides the operational control layer between authored configuration and live ESP runtime. Key responsibilities: device selection bridge lifecycle control status/identity visibility utility actions FS, echo, reboot applying downloaded firmware to connected ESP Header Controls device dropdown Select device… connection status dot/text firmware readout Refresh Reboot Sync Time Button availability depends on selected/connected device state. No-Device State When no ESP devices are available, a dedicated card explains that USB connection is required. Overview Card Displays: Port Chip IP RSSI Bridge section displays: Bridge Status Bridge Port Bridge Firmware Bridge Chip Bridge actions: Start Stop Restart Actions Card Operational tools: FS Status List Files Reboot ESP Echo Test Each action opens a result modal. Available result modals: FS Status modal File List modal Echo Test modal Reboot ESP modal Firmware Card Local Apply Purpose: apply locally downloaded firmware to connected ESP. List behaviour: shows locally available versions displays Latest and Current badges where relevant apply action per version upload console with progress/log output Compatibility and Confidence Checks ESPLink helps ensure safe rollout by exposing: bridge running state device presence live firmware/chip info clear checks that Pi and ESP are on matching versions and manifest data before deployment Typical Workflow Select target ESP device. Confirm status dot and overview data. Start/restart bridge if needed. Use Sync Time and utility checks. Apply firmware if required. Continue with hardware/rules/lighting sync actions. Practical Examples Recovery after USB reconnect press Refresh if bridge stopped, Start bridge verify chip/firmware visible again Pre-sync validation ensure connected status is green run Echo Test quickly check FS/list outputs if needed Related Features Hardware Firmware Logs","excerpt":"ESPLink ESPLink manages Pi-to-ESP connectivity, bridge control, firmware apply flow, and runtime utility actions. What This Feature Does ESPLink provides the operational control layer between authored configuration and..."},{"slug":"1-user-guide/12-firmware","path":"1-user-guide/12-firmware.md","title":"Firmware","order":12,"html":"<h1>Firmware</h1><p>Firmware manages available firmware version lists and local version lifecycle.</p><img src=\"./media/screenshot-feature-firmware.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/firmware\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Firmware feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>It provides a controlled view of firmware versions and allows you to download/remove local versions for deployment.</p><h2>Source Controls</h2><p>At the top of the card:</p><ul><li>Source selector:</li><li><code>Default</code></li><li><code>Custom URL</code></li><li>Remote URL input (shown in custom mode)</li><li><code>Load</code> for remote manifest fetch</li></ul><p>Status line shows:</p><ul><li>latest version badge</li><li>source label</li><li>version count summary</li></ul><h2>Versions Table</h2><p>Columns:</p><ul><li>Version</li><li>Date</li><li>Notes</li><li>Size</li><li>Status</li><li>Action</li></ul><p>Status badges include:</p><ul><li>Downloaded (local)</li><li>Remote</li></ul><p>Row actions:</p><ul><li><code>Download</code> for remote-only versions</li><li><code>Remove</code> for local versions</li></ul><h2>Footer Action</h2><ul><li><code>Remove All Local Versions</code></li></ul><p>Use this to clear local cache when resetting firmware set.</p><h2>Data Behaviour</h2><p>Firmware view merges local and selected-remote manifests.</p><p>Ordering:</p><ul><li>newest first by date/version sort</li></ul><p>Formatting:</p><ul><li>dates shown in readable UK format</li><li>sizes shown as B/KB/MB</li></ul><h2>Official Release Usage</h2><p>Updates from official Pinball CTL releases are available and listed here.</p><p>Typical workflow:</p><ol><li>load default source</li><li>review available versions/notes</li><li>download required local version</li><li>apply from ESPLink</li></ol><h2>Practical Examples</h2><h3>Use official default feed</h3><ul><li>keep Source = Default</li><li>review latest badge</li><li>download selected stable version</li></ul><h3>Temporary custom release source</h3><ul><li>switch Source = Custom URL</li><li>enter manifest URL</li><li>Load and review</li><li>download targeted version</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/11-esplink\">ESPLink</a></li><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li><li><a href=\"#doc=1-user-guide/13-service-log\">Service Log</a></li></ul>","plain":"Firmware Firmware manages available firmware version lists and local version lifecycle. What This Feature Does It provides a controlled view of firmware versions and allows you to download/remove local versions for deployment. Source Controls At the top of the card: Source selector: Default Custom URL Remote URL input shown in custom mode Load for remote manifest fetch Status line shows: latest version badge source label version count summary Versions Table Columns: Version Date Notes Size Status Action Status badges include: Downloaded local Remote Row actions: Download for remote-only versions Remove for local versions Footer Action Remove All Local Versions Use this to clear local cache when resetting firmware set. Data Behaviour Firmware view merges local and selected-remote manifests. Ordering: newest first by date/version sort Formatting: dates shown in readable UK format sizes shown as B/KB/MB Official Release Usage Updates from official Pinball CTL releases are available and listed here. Typical workflow: load default source review available versions/notes download required local version apply from ESPLink Practical Examples Use official default feed keep Source = Default review latest badge download selected stable version Temporary custom release source switch Source = Custom URL enter manifest URL Load and review download targeted version Related Features ESPLink Hardware Service Log","excerpt":"Firmware Firmware manages available firmware version lists and local version lifecycle. What This Feature Does It provides a controlled view of firmware versions and allows you to download/remove local versions for..."},{"slug":"1-user-guide/13-service-log","path":"1-user-guide/13-service-log.md","title":"Service Log","order":13,"html":"<h1>Service Log</h1><p>Service Log is the feature for machine service and maintenance records.</p><p>It is focused on physical maintenance history rather than runtime diagnostics.</p><img src=\"./media/screenshot-feature-servicelog.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/service\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Service Log feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>It records maintenance and repair actions so users and engineers can track what was serviced, when, and why.</p><h2>Top Controls</h2><ul><li><code>New Entry</code></li></ul><p>Creates a new maintenance/service record.</p><h2>Filter Controls</h2><ul><li>Service type filter</li><li>Date <code>From</code></li><li>Date <code>To</code></li><li><code>Apply</code></li><li><code>Clear</code></li></ul><p>Service types:</p><ul><li>Service</li><li>Repair</li><li>Recall</li><li>Warranty</li></ul><h2>Main Layout</h2><p>Two-pane layout:</p><ul><li>left: Entries list + count badge</li><li>right: Entry details panel</li></ul><p>Details panel shows:</p><ul><li>title/meta/type</li><li>work summary</li><li>parts replaced</li><li>outcome</li><li>follow-up notes</li><li>attachments</li></ul><p><code>Edit</code> button appears when an entry is selected.</p><h2>New/Edit Entry Modal</h2><p>Fields:</p><ul><li>Engineer (required)</li><li>Service type (required)</li><li>Title (required)</li><li>Work description (required)</li><li>Parts replaced</li><li>Outcome / result</li><li>Follow-up notes</li><li>Attachments (up to 5 files)</li></ul><p>Attachment note in UI:</p><ul><li>PNG, JPG, PDF, DOCX</li></ul><p>Modal actions:</p><ul><li>Cancel</li><li>Save Entry</li></ul><h2>Typical Workflow</h2><ol><li>Create entry after physical work is complete.</li><li>Capture parts/outcome details.</li><li>Add supporting attachments.</li><li>Save and verify details in right panel.</li></ol><h2>Practical Examples</h2><h3>Weekly cleaning log</h3><p>Record:</p><ul><li>engineer/operator</li><li>service type = Service</li><li>checklist summary</li><li>follow-up for next clean interval</li></ul><h3>Coil replacement record</h3><p>Record:</p><ul><li>type = Repair</li><li>replaced part ID</li><li>result after test</li><li>attach invoice/photo</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/5-dashboard\">Dashboard</a></li><li><a href=\"#doc=1-user-guide/14-logs\">Logs</a></li><li><a href=\"#doc=1-user-guide/16-settings\">Settings</a></li></ul>","plain":"Service Log Service Log is the feature for machine service and maintenance records. It is focused on physical maintenance history rather than runtime diagnostics. What This Feature Does It records maintenance and repair actions so users and engineers can track what was serviced, when, and why. Top Controls New Entry Creates a new maintenance/service record. Filter Controls Service type filter Date From Date To Apply Clear Service types: Service Repair Recall Warranty Main Layout Two-pane layout: left: Entries list + count badge right: Entry details panel Details panel shows: title/meta/type work summary parts replaced outcome follow-up notes attachments Edit button appears when an entry is selected. New/Edit Entry Modal Fields: Engineer required Service type required Title required Work description required Parts replaced Outcome / result Follow-up notes Attachments up to 5 files Attachment note in UI: PNG, JPG, PDF, DOCX Modal actions: Cancel Save Entry Typical Workflow Create entry after physical work is complete. Capture parts/outcome details. Add supporting attachments. Save and verify details in right panel. Practical Examples Weekly cleaning log Record: engineer/operator service type = Service checklist summary follow-up for next clean interval Coil replacement record Record: type = Repair replaced part ID result after test attach invoice/photo Related Features Dashboard Logs Settings","excerpt":"Service Log Service Log is the feature for machine service and maintenance records. It is focused on physical maintenance history rather than runtime diagnostics. What This Feature Does It records maintenance and repair..."},{"slug":"1-user-guide/14-logs","path":"1-user-guide/14-logs.md","title":"Logs","order":14,"html":"<h1>Logs</h1><p>Logs is the feature for viewing runtime output from web, bridge, ESP, and event streams.</p><img src=\"./media/screenshot-feature-logs.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/logs\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Logs feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>It provides live and historical log access in-browser for operational checks and troubleshooting.</p><h2>Control Bar Reference</h2><h3>Source</h3><p>Available sources:</p><ul><li>Web Error</li><li>Web Access</li><li>Bridge</li><li>ESP Raw</li><li>Events</li></ul><p>Source preference is remembered in local storage.</p><h3>Lines</h3><ul><li>numeric line count for current-window view</li><li>min/step controlled input</li></ul><h3>Filter</h3><ul><li>keyword filter applied client-side to visible buffer</li></ul><h3>Log File</h3><ul><li><code>Current</code> and archive entries (when available)</li></ul><p>Archive mode hides controls that are not applicable to archived logs.</p><h3>Action buttons</h3><ul><li><code>Refresh</code></li><li><code>Clear</code></li><li><code>Purge</code></li><li><code>Tailing</code> toggle</li></ul><p><code>Purge</code> permanently clears the current log file (with confirmation).</p><h2>Viewport Behaviour</h2><ul><li>renders log lines as interactive rows</li><li>auto-tail updates while enabled</li><li>supports large buffer management</li></ul><p>Rows with parseable JSON show JSON-specific affordance.</p><h2>JSON Inspector</h2><p>Click <code>JSON</code> or row to open inspector modal.</p><p>Modal includes:</p><ul><li>structured syntax-highlighted JSON view</li><li>fallback raw line view if not JSON</li><li>close actions and <code>Esc</code> support</li></ul><h2>Tailing and Selection Behaviour</h2><p>When text selection is active in viewport:</p><ul><li>render updates are deferred to avoid disrupting text copy/select</li></ul><p>Tail can be toggled off for static analysis.</p><h2>Typical Workflow</h2><ol><li>Select source.</li><li>Set line window.</li><li>Apply keyword filter.</li><li>Inspect JSON rows when needed.</li><li>Use purge only for deliberate log reset.</li></ol><h2>Practical Examples</h2><h3>Bridge troubleshooting</h3><ul><li>source = Bridge</li><li>tailing on</li><li>filter for <code>error</code>, <code>timeout</code>, or device ID</li></ul><h3>Event audit</h3><ul><li>source = Events</li><li>inspect JSON payloads for event names/fields</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/5-dashboard\">Dashboard</a></li><li><a href=\"#doc=1-user-guide/11-esplink\">ESPLink</a></li><li><a href=\"#doc=1-user-guide/13-service-log\">Service Log</a></li></ul>","plain":"Logs Logs is the feature for viewing runtime output from web, bridge, ESP, and event streams. What This Feature Does It provides live and historical log access in-browser for operational checks and troubleshooting. Control Bar Reference Source Available sources: Web Error Web Access Bridge ESP Raw Events Source preference is remembered in local storage. Lines numeric line count for current-window view min/step controlled input Filter keyword filter applied client-side to visible buffer Log File Current and archive entries when available Archive mode hides controls that are not applicable to archived logs. Action buttons Refresh Clear Purge Tailing toggle Purge permanently clears the current log file with confirmation . Viewport Behaviour renders log lines as interactive rows auto-tail updates while enabled supports large buffer management Rows with parseable JSON show JSON-specific affordance. JSON Inspector Click JSON or row to open inspector modal. Modal includes: structured syntax-highlighted JSON view fallback raw line view if not JSON close actions and Esc support Tailing and Selection Behaviour When text selection is active in viewport: render updates are deferred to avoid disrupting text copy/select Tail can be toggled off for static analysis. Typical Workflow Select source. Set line window. Apply keyword filter. Inspect JSON rows when needed. Use purge only for deliberate log reset. Practical Examples Bridge troubleshooting source = Bridge tailing on filter for error, timeout, or device ID Event audit source = Events inspect JSON payloads for event names/fields Related Features Dashboard ESPLink Service Log","excerpt":"Logs Logs is the feature for viewing runtime output from web, bridge, ESP, and event streams. What This Feature Does It provides live and historical log access in-browser for operational checks and troubleshooting...."},{"slug":"1-user-guide/15-wifi","path":"1-user-guide/15-wifi.md","title":"Wi Fi","order":15,"html":"<h1>Wi-Fi</h1><p>Wi-Fi is the feature for viewing and updating network connection settings.</p><img src=\"./media/screenshot-feature-wifi.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/wifi\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Wi-Fi feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>What This Feature Does</h2><p>It shows live network state and lets you update SSID/password from the web interface.</p><h2>Current Status Card</h2><p>Displays:</p><ul><li>SSID</li><li>IP</li><li>State</li><li>Connected badge (<code>Yes</code>/<code>No</code>)</li></ul><p>Status refreshes regularly (about every 5 seconds).</p><h2>Update Settings Form</h2><p>Fields:</p><ul><li>SSID (required)</li><li>Password</li></ul><p>Actions:</p><ul><li><code>Save</code></li></ul><p>UI feedback:</p><ul><li>saving spinner</li><li>success message</li><li>error alert if save fails</li></ul><h2>Save Behaviour</h2><p>Saves are submitted to Wi-Fi API and status refresh is triggered after successful update.</p><p>Use this for first setup changes or network migration.</p><h2>Planned Capability</h2><p>Planned: Wi-Fi connected services will provide support for global leaderboards.</p><h2>Practical Examples</h2><h3>Move machine to new venue network</h3><ol><li>Enter new SSID/password.</li><li>Save.</li><li>Confirm new IP and connected badge.</li></ol><h3>Verify remote support readiness</h3><p>Confirm connected badge and IP before remote browser/API operations.</p><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/5-dashboard\">Dashboard</a></li><li><a href=\"#doc=1-user-guide/16-settings\">Settings</a></li></ul>","plain":"Wi-Fi Wi-Fi is the feature for viewing and updating network connection settings. What This Feature Does It shows live network state and lets you update SSID/password from the web interface. Current Status Card Displays: SSID IP State Connected badge Yes/No Status refreshes regularly about every 5 seconds . Update Settings Form Fields: SSID required Password Actions: Save UI feedback: saving spinner success message error alert if save fails Save Behaviour Saves are submitted to Wi-Fi API and status refresh is triggered after successful update. Use this for first setup changes or network migration. Planned Capability Planned: Wi-Fi connected services will provide support for global leaderboards. Practical Examples Move machine to new venue network Enter new SSID/password. Save. Confirm new IP and connected badge. Verify remote support readiness Confirm connected badge and IP before remote browser/API operations. Related Features Dashboard Settings","excerpt":"Wi-Fi Wi-Fi is the feature for viewing and updating network connection settings. What This Feature Does It shows live network state and lets you update SSID/password from the web interface. Current Status Card Displays:..."},{"slug":"1-user-guide/16-settings","path":"1-user-guide/16-settings.md","title":"Settings","order":16,"html":"<h1>Settings</h1><p>Settings is the feature for installation-wide configuration and project data transfer.</p><img src=\"./media/screenshot-feature-settings.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/settings\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Settings feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>Page Structure</h2><p>Settings has two tabs:</p><ol><li><code>Settings</code></li><li><code>Import/Export</code></li></ol><h2>Settings Tab</h2><img src=\"./media/screenshot-feature-settings-settings.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/settings\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Settings tab overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Use this tab to manage persistent system values.</p><p>Main fields:</p><ul><li>project name</li><li>admin username</li><li>admin password</li><li>remote firmware URL</li><li>log level (<code>INFO</code>, <code>DEBUG</code>, <code>VERBOSE</code>)</li><li>currency (<code>GBP</code>, <code>USD</code>, <code>EUR</code>, <code>JPY</code>)</li><li><code>Start displays on service startup</code></li></ul><p>Top action:</p><ul><li><code>Save Changes</code></li></ul><p>Password behavior:</p><ul><li>blank password does not overwrite existing password</li><li>non-empty password replaces admin password</li></ul><h2>Import/Export Tab</h2><img src=\"./media/screenshot-feature-settings-import-export.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/settings\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Import and export tab overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Use this tab to move project data between installations.</p><h3>Export project</h3><ul><li>downloads a bundle of <code>src/instance</code></li><li>filename includes project name and timestamp</li><li>status text shows progress/completion</li><li>action: <code>Export</code></li></ul><h3>Import project</h3><ul><li>uploads a bundled project export (<code>.zip</code>)</li><li>existing files in <code>src/instance</code> are overwritten when present</li><li>confirmation is required before import</li><li>status text shows upload result</li><li>controls: file chooser + <code>Import</code></li></ul><h2>Typical Workflow</h2><ol><li>Update values in <code>Settings</code>.</li><li>Click <code>Save Changes</code>.</li><li>Use <code>Import/Export</code> for backup, restore, or migration.</li></ol><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/18-media\">Media</a></li><li><a href=\"#doc=1-user-guide/15-wifi\">Wi-Fi</a></li><li><a href=\"#doc=1-user-guide/12-firmware\">Firmware</a></li></ul>","plain":"Settings Settings is the feature for installation-wide configuration and project data transfer. Page Structure Settings has two tabs: Settings Import/Export Settings Tab Use this tab to manage persistent system values. Main fields: project name admin username admin password remote firmware URL log level INFO, DEBUG, VERBOSE currency GBP, USD, EUR, JPY Start displays on service startup Top action: Save Changes Password behavior: blank password does not overwrite existing password non-empty password replaces admin password Import/Export Tab Use this tab to move project data between installations. Export project downloads a bundle of src/instance filename includes project name and timestamp status text shows progress/completion action: Export Import project uploads a bundled project export .zip existing files in src/instance are overwritten when present confirmation is required before import status text shows upload result controls: file chooser + Import Typical Workflow Update values in Settings. Click Save Changes. Use Import/Export for backup, restore, or migration. Related Features Media Wi-Fi Firmware","excerpt":"Settings Settings is the feature for installation-wide configuration and project data transfer. Page Structure Settings has two tabs: Settings Import/Export Settings Tab Use this tab to manage persistent system values...."},{"slug":"1-user-guide/17-audio","path":"1-user-guide/17-audio.md","title":"Audio","order":17,"html":"<h1>Audio</h1><p>Audio manages sound assets, output routing, and cue-based playback behavior.</p><p>It is designed so gameplay systems can trigger predictable audio without embedding sound logic in ESP firmware.</p><h2>Page Structure</h2><p>Audio is split into four tabs:</p><ol><li><code>Library</code></li><li><code>Cues</code></li><li><code>Outputs</code></li><li><code>Audio Usage Map</code></li></ol><h2>Library Tab</h2><img src=\"./media/screenshot-feature-audio-library.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/audio\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Audio library tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Library is where audio files are uploaded and managed.</p><p>Key behavior:</p><ul><li>drag-and-drop multi-file upload</li><li>per-row inline player</li><li>friendly name editing</li><li>sort by name, added date, and duration</li><li>usage count pills per asset</li></ul><p>Notes:</p><ul><li>if no friendly name is set, UI derives one from filename</li><li>very short assets are shown with fractional-second durations</li></ul><h2>Cues Tab</h2><img src=\"./media/screenshot-feature-audio-cues.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/audio\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Audio cues tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Cues define how assets play at runtime.</p><p>Per cue settings include:</p><ul><li>cue name</li><li>linked library asset</li><li>output target</li><li>bus (<code>SFX</code>, <code>Music</code>, <code>Voice</code>, <code>Ambient</code>)</li><li>volume (<code>0.0</code> to <code>2.0</code>)</li><li>loop toggle</li><li>repeat count</li><li>cooldown (ms)</li></ul><p>Editor behavior:</p><ul><li><code>Save Changes</code> enables only when there are real changes</li><li>unsaved exit prompts use the shared confirm flow</li><li>preview playback goes through backend routing for runtime-accurate output targeting</li></ul><h2>Outputs Tab</h2><img src=\"./media/screenshot-feature-audio-outputs.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/audio\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Audio outputs tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Outputs shows devices and runtime playback state.</p><p>Key behavior:</p><ul><li>detected playback devices for current host</li><li>active runtime entries and orphan entries</li><li>stop actions for active/orphan playback processes</li><li>environment checks for audio backend/library readiness</li></ul><h2>Audio Usage Map Tab</h2><img src=\"./media/screenshot-feature-audio-audio-usage-map.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/audio\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Audio usage map tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Audio Usage Map is a read-only reference of where assets are used.</p><p>Use it for:</p><ul><li>audit and cleanup</li><li>verifying reuse before adding duplicate assets</li><li>debugging event-to-cue mappings quickly</li></ul><h2>Runtime Model</h2><p>Audio subscribes to Pi-side event flow.</p><p>In practice:</p><ul><li>events can trigger cues</li><li>multiple systems can reference the same cue</li><li>behavior stays centrally configurable from Audio</li></ul><h2>Typical Workflow</h2><ol><li>Upload assets in <code>Library</code>.</li><li>Define cue behavior in <code>Cues</code>.</li><li>Validate devices and playback in <code>Outputs</code>.</li><li>Confirm usage and reuse in <code>Audio Usage Map</code>.</li></ol><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/7.1-scoring\">Scoring</a></li><li><a href=\"#doc=1-user-guide/9-layout\">Playfield</a></li><li><a href=\"#doc=1-user-guide/16-settings\">Settings</a></li></ul>","plain":"Audio Audio manages sound assets, output routing, and cue-based playback behavior. It is designed so gameplay systems can trigger predictable audio without embedding sound logic in ESP firmware. Page Structure Audio is split into four tabs: Library Cues Outputs Audio Usage Map Library Tab Library is where audio files are uploaded and managed. Key behavior: drag-and-drop multi-file upload per-row inline player friendly name editing sort by name, added date, and duration usage count pills per asset Notes: if no friendly name is set, UI derives one from filename very short assets are shown with fractional-second durations Cues Tab Cues define how assets play at runtime. Per cue settings include: cue name linked library asset output target bus SFX, Music, Voice, Ambient volume 0.0 to 2.0 loop toggle repeat count cooldown ms Editor behavior: Save Changes enables only when there are real changes unsaved exit prompts use the shared confirm flow preview playback goes through backend routing for runtime-accurate output targeting Outputs Tab Outputs shows devices and runtime playback state. Key behavior: detected playback devices for current host active runtime entries and orphan entries stop actions for active/orphan playback processes environment checks for audio backend/library readiness Audio Usage Map Tab Audio Usage Map is a read-only reference of where assets are used. Use it for: audit and cleanup verifying reuse before adding duplicate assets debugging event-to-cue mappings quickly Runtime Model Audio subscribes to Pi-side event flow. In practice: events can trigger cues multiple systems can reference the same cue behavior stays centrally configurable from Audio Typical Workflow Upload assets in Library. Define cue behavior in Cues. Validate devices and playback in Outputs. Confirm usage and reuse in Audio Usage Map. Related Features Rules Scoring Playfield Settings","excerpt":"Audio Audio manages sound assets, output routing, and cue-based playback behavior. It is designed so gameplay systems can trigger predictable audio without embedding sound logic in ESP firmware. Page Structure Audio is..."},{"slug":"1-user-guide/18-media","path":"1-user-guide/18-media.md","title":"Media","order":18,"html":"<h1>Media</h1><p>Media is the scene authoring feature for videos and on-screen overlays.</p><p>It lets you build stage scenes, preview them in-browser, and launch kiosk windows on configured displays.</p><h2>Page Structure</h2><p>Media is split into four tabs:</p><ol><li><code>Stage</code></li><li><code>Library</code></li><li><code>Displays</code></li><li><code>Runtime</code></li></ol><h2>Stage Tab</h2><img src=\"./media/screenshot-feature-media-stage.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/media\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Media stage tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Stage is the authoring tab for scene composition and playback preview.</p><p>Left panel:</p><ul><li>visual preview stage</li><li>playback controls (<code>Play / Pause</code>, <code>Stop</code>, scrub bar, time readout)</li><li>launch buttons (<code>Open Fullscreen</code>, <code>Open Small Window</code>)</li></ul><p>Right panel cards:</p><ul><li><code>Scenes</code>: scene dropdown + <code>+ Add Scene</code></li><li><code>Options</code>: scene name, target display, base asset, loop, audio include toggle</li><li><code>Overlays</code>: overlay list + editor + <code>+ Add Overlay</code></li></ul><p>Overlay editing includes:</p><ul><li>reorder (up/down)</li><li>collapse/expand per overlay</li><li>position, size, rotation, opacity</li><li>text options (alignment, effects, no-wrap rendering)</li><li>image/frame/variable overlay configuration</li></ul><h2>Library Tab</h2><img src=\"./media/screenshot-feature-media-library.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/media\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Media library tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Library manages media assets.</p><p>Cards:</p><ul><li><code>Asset Upload</code></li><li>drag/drop upload</li><li>file picker upload</li><li>progress/status feedback</li><li><code>Asset Library</code></li><li>asset list with name, type, added date, and actions</li><li>in-app preview for selected assets</li></ul><h2>Displays Tab</h2><img src=\"./media/screenshot-feature-media-displays.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/media\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Media displays tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Displays is for output-target configuration and host readiness.</p><p>Cards:</p><ul><li><code>Detected Displays</code></li><li>display name, role, size, screen mapping, enabled state</li><li><code>Detect</code> action refresh</li><li><code>Runtime Checks</code></li><li>kiosk/runtime dependency checks</li><li>Chromium/runtime capability status</li></ul><h2>Runtime Tab</h2><img src=\"./media/screenshot-feature-media-runtime.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/media\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Media runtime tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Runtime shows active scene sessions and runtime controls.</p><p>Cards:</p><ul><li><code>Runtime</code></li><li>active scene list by display/session</li><li>per-scene stop actions</li><li><code>Controls</code></li><li>global runtime actions such as <code>Stop All</code></li></ul><h2>Typical Workflow</h2><ol><li>Build a scene in <code>Stage</code>.</li><li>Choose target display and base asset.</li><li>Add and tune overlays in preview.</li><li>Save changes.</li><li>Launch fullscreen or small window for live validation.</li><li>Verify/monitor sessions in <code>Runtime</code>.</li></ol><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/8-lighting\">Lighting</a></li><li><a href=\"#doc=1-user-guide/16-settings\">Settings</a></li></ul>","plain":"Media Media is the scene authoring feature for videos and on-screen overlays. It lets you build stage scenes, preview them in-browser, and launch kiosk windows on configured displays. Page Structure Media is split into four tabs: Stage Library Displays Runtime Stage Tab Stage is the authoring tab for scene composition and playback preview. Left panel: visual preview stage playback controls Play / Pause, Stop, scrub bar, time readout launch buttons Open Fullscreen, Open Small Window Right panel cards: Scenes: scene dropdown + + Add Scene Options: scene name, target display, base asset, loop, audio include toggle Overlays: overlay list + editor + + Add Overlay Overlay editing includes: reorder up/down collapse/expand per overlay position, size, rotation, opacity text options alignment, effects, no-wrap rendering image/frame/variable overlay configuration Library Tab Library manages media assets. Cards: Asset Upload drag/drop upload file picker upload progress/status feedback Asset Library asset list with name, type, added date, and actions in-app preview for selected assets Displays Tab Displays is for output-target configuration and host readiness. Cards: Detected Displays display name, role, size, screen mapping, enabled state Detect action refresh Runtime Checks kiosk/runtime dependency checks Chromium/runtime capability status Runtime Tab Runtime shows active scene sessions and runtime controls. Cards: Runtime active scene list by display/session per-scene stop actions Controls global runtime actions such as Stop All Typical Workflow Build a scene in Stage. Choose target display and base asset. Add and tune overlays in preview. Save changes. Launch fullscreen or small window for live validation. Verify/monitor sessions in Runtime. Related Features Rules Lighting Settings","excerpt":"Media Media is the scene authoring feature for videos and on-screen overlays. It lets you build stage scenes, preview them in-browser, and launch kiosk windows on configured displays. Page Structure Media is split into..."},{"slug":"1-user-guide/2-interface","path":"1-user-guide/2-interface.md","title":"Interface Tour","order":2,"html":"<h1>Interface Tour</h1><p>This page gives you a quick tour of the Pinball CTL interface so you can find what you need fast.</p><h2>Login</h2><p>Open Pinball CTL in your browser and sign in.</p><img src=\"./media/screenshot-login.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true}' alt=\"Pinball CTL login screen\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Default login credentials:</p><ul><li>Username: <code>admin</code></li><li>Password: <code>password</code></li></ul><p>Change the default password after your first login via <code>System -&gt; Settings</code>.</p><h2>Dashboard Overview</h2><p>After login, you land on the Dashboard. This is your at-a-glance machine status page.</p><img src=\"./media/screenshot-dashboard.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/dashboard\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Pinball CTL dashboard\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>The dashboard cards show key status areas such as Wi-Fi, bridge state, ESP32 connectivity, dependencies, uptime, and gameplay or machine metrics.</p><p>Use this page first when checking whether your system is healthy.</p><h2>Control Centre</h2><p>Use the grid icon in the top bar to open the Control Centre. This is the main navigation hub for all areas.</p><img src=\"./media/screenshot-control-center.png\"\n     data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"wait\",\"wait_for\":\"#flood-menu-body .flood-grid\"}]}'\n     alt=\"Pinball CTL control centre\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>The Control Centre groups pages by purpose:</p><ul><li>Overview: high-level operational pages.</li><li>Authoring: Rules, Lighting, and playfield-related work.</li><li>Platform: hardware, firmware, and ESPLink.</li><li>Operations: logs and service diagnostics.</li><li>System: settings such as Wi-Fi and install-wide options.</li></ul><h2>Search</h2><p>Use the search box (top right of Control Centre) to filter the available pages.</p><img src=\"./media/screenshot-control-center-search.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"wait\",\"wait_for\":\"#flood-menu-body .flood-grid\"}],\"highlight\":{\"selector\":\".flood-menu-head-actions\",\"style\":\"border: 4px solid red; border-radius: 8px;\"}}' alt=\"Control Centre search box\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Search is best when you type the page name directly, for example: <code>lighting</code>, <code>rules</code>, or <code>hardware</code>, then click the page you want.</p><h2>Recently Visited</h2><p>Pinball CTL keeps quick shortcuts so you can get back to pages you use most.</p><p>The Recently Visited row gives one-click access to pages you opened recently.</p><img src=\"./media/screenshot-control-center-recent.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"h1\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"hardware\\\"]\",\"wait_for\":\"h1\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"settings\\\"]\",\"wait_for\":\"h1\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"wait\",\"wait_for\":\".flood-recent\"}],\"highlight\":{\"selector\":\".flood-recent\",\"style\":\"border: 4px solid red; border-radius: 8px; padding: 6px;\"}}' alt=\"Recently visited pages\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>Bookmarks</h2><p>When you hover over a link, a yellow bookmark icon appears.</p><p>Clicking the icon adds that link to the top bookmarks menu for faster access to frequently used areas.</p><p>You can also drag and drop items in the top bookmarks menu to arrange them in your preferred order.</p>","plain":"Interface Tour This page gives you a quick tour of the Pinball CTL interface so you can find what you need fast. Login Open Pinball CTL in your browser and sign in. Default login credentials: Username: admin Password: password Change the default password after your first login via System -> Settings. Dashboard Overview After login, you land on the Dashboard. This is your at-a-glance machine status page. The dashboard cards show key status areas such as Wi-Fi, bridge state, ESP32 connectivity, dependencies, uptime, and gameplay or machine metrics. Use this page first when checking whether your system is healthy. Control Centre Use the grid icon in the top bar to open the Control Centre. This is the main navigation hub for all areas. The Control Centre groups pages by purpose: Overview: high-level operational pages. Authoring: Rules, Lighting, and playfield-related work. Platform: hardware, firmware, and ESPLink. Operations: logs and service diagnostics. System: settings such as Wi-Fi and install-wide options. Search Use the search box top right of Control Centre to filter the available pages. Search is best when you type the page name directly, for example: lighting, rules, or hardware, then click the page you want. Recently Visited Pinball CTL keeps quick shortcuts so you can get back to pages you use most. The Recently Visited row gives one-click access to pages you opened recently. Bookmarks When you hover over a link, a yellow bookmark icon appears. Clicking the icon adds that link to the top bookmarks menu for faster access to frequently used areas. You can also drag and drop items in the top bookmarks menu to arrange them in your preferred order.","excerpt":"Interface Tour This page gives you a quick tour of the Pinball CTL interface so you can find what you need fast. Login Open Pinball CTL in your browser and sign in. Default login credentials: Username: admin Password:..."},{"slug":"1-user-guide/3-featured","path":"1-user-guide/3-featured.md","title":"Features","order":3,"html":"<h1>Features</h1><p>This page gives you a full overview of the main Pinball CTL features.</p><p>Use the table for a quick summary, then use the detailed sections to understand what each area does.</p><h2>At-a-Glance Feature Table</h2><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Name</th>        <th>Purpose</th>      </tr>    </thead>    <tbody>      <tr><td>Dashboard</td><td>Live overview of machine state, connectivity, and runtime health.</td></tr>      <tr><td>Rules</td><td>Create and manage gameplay rules, triggers, and actions.</td></tr>      <tr><td>Scoring</td><td>Author points, progressive scoring rules, and combo scoring logic.</td></tr>      <tr><td>Audio</td><td>Manage sound assets, cue playback behavior, output routing, and usage mapping.</td></tr>      <tr><td>Media</td><td>Build visual scenes with assets and overlays, then launch kiosk displays for runtime.</td></tr>      <tr><td>Lighting</td><td>Author scene-based lighting with rich live preview before rollout.</td></tr>      <tr><td>Playfield</td><td>Visual playfield editor with live simulation preview for faster iteration.</td></tr>      <tr><td>Hardware</td><td>Discover hardware, map inputs/outputs, and manage hardware configuration.</td></tr>      <tr><td>ESPLink</td><td>Manage ESP32 link status, versions, and manifest sync workflow.</td></tr>      <tr><td>Firmware</td><td>Firmware package and deployment support for ESP32 targets.</td></tr>      <tr><td>Service Log</td><td>Service and maintenance logging for users and engineers.</td></tr>      <tr><td>Logs</td><td>View and inspect application and bridge logs from the web UI.</td></tr>      <tr><td>Wi-Fi</td><td>Network connection status and Wi-Fi setup controls.</td></tr>      <tr><td>Settings</td><td>System-wide configuration, identity, and environment options.</td></tr>    </tbody>  </table></div><h2>Dashboard</h2><p>The Dashboard is the first operational view after login. It is designed for quick checks before you start rule or lighting work.</p><p>Key features:</p><ul><li>Live status cards for network, bridge, ESP32 link, and uptime.</li><li>Dependency visibility for required tooling.</li><li>High-level machine and gameplay metrics in one place.</li><li>Fast way to spot faults before troubleshooting deeper features.</li></ul><h2>Rules</h2><p>Rules is the gameplay authoring area. It defines how machine events trigger actions and behaviour.</p><p>Key features:</p><ul><li>Rule creation and editing workflows.</li><li>Trigger and condition-based action execution.</li><li>Integration with lighting actions (including scene selection and control options).</li><li>Structured configuration storage for repeatable deployments.</li></ul><h2>Scoring</h2><p>Scoring is the point-system authoring area. It lets you build base points, progressive hit rules, and combo awards without writing code.</p><p>Key features:</p><ul><li>Base points table for fixed score awards from hardware and fired events.</li><li>Progressive scoring rules with minimum hit thresholds and optional time windows.</li><li>Cooloff controls to reduce hit streak value over time.</li><li>Combo authoring with ordered or any-order step matching.</li><li>Optional combo multipliers and emitted events for integration with Rules and Lighting.</li></ul><h2>Audio</h2><p>Audio manages sound assets and runtime playback rules from one place on the Pi side.</p><p>Key features:</p><ul><li>Asset library with multi-upload and inline preview.</li><li>Cue editor for output, bus, volume, loop, repeats, and cooldown.</li><li>Output/device visibility and runtime playback monitoring.</li><li>Usage mapping for quick cue/asset lookup and diagnostics.</li></ul><h2>Media</h2><p>Media is the scene authoring and playback module for videos and overlays across your configured displays.</p><p>Key features:</p><ul><li>Stage editor with scene selector, options, overlays, and live preview.</li><li>Launch controls for fullscreen kiosk and small-window testing.</li><li>Library tab for asset upload, browsing, and preview.</li><li>Displays tab for detection and runtime environment checks.</li><li>Runtime tab for active scene visibility and stop controls.</li></ul><h2>Lighting</h2><p>Lighting is a full scene authoring workflow for table effects and player feedback.</p><p>Key features:</p><ul><li>Scene and timeline editing.</li><li>Pattern-based animation generation.</li><li>Custom keyframes and tag-based frame markers.</li><li>Cast targeting, layering options, and playback controls.</li><li>Build your lighting plan by scene, timeline, and target selection.</li><li>Apply pattern/show behaviour and test playback in preview before rollout.</li><li>Tune behaviour safely without requiring immediate live hardware control.</li></ul><h2>Playfield</h2><p>Playfield is the visual model of your playfield and hardware placement.</p><p>Key features:</p><ul><li>Placement and sizing of playfield elements.</li><li>Simulation preview for quick visual validation as you build.</li><li>Hardware binding support for visual validation.</li><li>Editing tools to maintain a clean machine map.</li><li>Preview the playfield changes before applying them to your live machine workflow.</li><li>Playfield event handling mirrors hardware flow, so triggers and responses behave consistently.</li><li>Test trigger logic with immediate on-screen feedback that reflects hardware events.</li><li>Useful reference context when authoring rules and lighting.</li></ul><h2>Hardware</h2><p>Hardware manages the machine&#x27;s physical I/O mapping and integration data used by runtime services.</p><p>Key features:</p><ul><li>Mapping of switches, coils, lights, and related channels.</li><li>Hardware profile and mapping management.</li><li>Data used by bridge/runtime deployment steps.</li><li>Foundation for safe, deterministic control at runtime.</li></ul><h2>ESPLink</h2><p>ESPLink manages the Pi-to-ESP workflow and device-side compatibility checks.</p><p>Key features:</p><ul><li>Connection and sync status visibility.</li><li>Clear checks that Pi and ESP are on matching versions and manifest data before deployment.</li><li>Workflow support for updating or synchronising device state.</li><li>Integration point between authoring on Pi and execution on ESP32.</li></ul><h2>Firmware</h2><p>Firmware supports firmware package handling and update flow for ESP targets.</p><p>Key features:</p><ul><li>Firmware metadata and package handling.</li><li>Updates from official Pinball CTL releases are available and listed here.</li><li>Assisted update/deploy workflow hooks.</li><li>Clear separation between host-side authoring and device runtime code.</li><li>Useful for controlled release and maintenance tasks.</li></ul><h2>Service Log</h2><p>Service Log focuses on service and maintenance history for managed services.</p><p>Key features:</p><ul><li>Service and maintenance logging for users and engineers.</li><li>Maintenance history for physical machine work such as cleaning and inspections.</li><li>Records of hardware replacement and service actions over time.</li><li>Helps teams track what was serviced, when it was done, and what changed.</li><li>Helps confirm long-running service stability.</li></ul><h2>Logs</h2><p>Logs provides direct access to application and bridge output for troubleshooting.</p><p>Key features:</p><ul><li>Read runtime logs from the web UI.</li><li>Inspect bridge and web logging without leaving the browser.</li><li>Useful for identifying serial, protocol, or configuration issues.</li><li>Supports day-to-day diagnostics during development and testing.</li></ul><h2>Wi-Fi</h2><p>Wi-Fi shows and manages network connection details relevant to remote use.</p><p>Key features:</p><ul><li>Current connection status and interface details.</li><li>Wi-Fi setup/update controls.</li><li>Helps confirm browser access and API reachability.</li><li>Core tool for headless Pi deployments.</li><li>Planned: Wi-Fi connected services will provide support for global leaderboards.</li></ul><h2>Settings</h2><p>Settings contains installation-wide configuration options.</p><p>Key features:</p><ul><li>Identity and general system settings.</li><li>Security-related settings such as login credentials.</li><li>Import/export style configuration workflows where supported.</li><li>Central place for persistent environment-level options.</li></ul>","plain":"Features This page gives you a full overview of the main Pinball CTL features. Use the table for a quick summary, then use the detailed sections to understand what each area does. At-a-Glance Feature Table Name Purpose Dashboard Live overview of machine state, connectivity, and runtime health. Rules Create and manage gameplay rules, triggers, and actions. Scoring Author points, progressive scoring rules, and combo scoring logic. Audio Manage sound assets, cue playback behavior, output routing, and usage mapping. Media Build visual scenes with assets and overlays, then launch kiosk displays for runtime. Lighting Author scene-based lighting with rich live preview before rollout. Playfield Visual playfield editor with live simulation preview for faster iteration. Hardware Discover hardware, map inputs/outputs, and manage hardware configuration. ESPLink Manage ESP32 link status, versions, and manifest sync workflow. Firmware Firmware package and deployment support for ESP32 targets. Service Log Service and maintenance logging for users and engineers. Logs View and inspect application and bridge logs from the web UI. Wi-Fi Network connection status and Wi-Fi setup controls. Settings System-wide configuration, identity, and environment options. Dashboard The Dashboard is the first operational view after login. It is designed for quick checks before you start rule or lighting work. Key features: Live status cards for network, bridge, ESP32 link, and uptime. Dependency visibility for required tooling. High-level machine and gameplay metrics in one place. Fast way to spot faults before troubleshooting deeper features. Rules Rules is the gameplay authoring area. It defines how machine events trigger actions and behaviour. Key features: Rule creation and editing workflows. Trigger and condition-based action execution. Integration with lighting actions including scene selection and control options . Structured configuration storage for repeatable deployments. Scoring Scoring is the point-system authoring area. It lets you build base points, progressive hit rules, and combo awards without writing code. Key features: Base points table for fixed score awards from hardware and fired events. Progressive scoring rules with minimum hit thresholds and optional time windows. Cooloff controls to reduce hit streak value over time. Combo authoring with ordered or any-order step matching. Optional combo multipliers and emitted events for integration with Rules and Lighting. Audio Audio manages sound assets and runtime playback rules from one place on the Pi side. Key features: Asset library with multi-upload and inline preview. Cue editor for output, bus, volume, loop, repeats, and cooldown. Output/device visibility and runtime playback monitoring. Usage mapping for quick cue/asset lookup and diagnostics. Media Media is the scene authoring and playback module for videos and overlays across your configured displays. Key features: Stage editor with scene selector, options, overlays, and live preview. Launch controls for fullscreen kiosk and small-window testing. Library tab for asset upload, browsing, and preview. Displays tab for detection and runtime environment checks. Runtime tab for active scene visibility and stop controls. Lighting Lighting is a full scene authoring workflow for table effects and player feedback. Key features: Scene and timeline editing. Pattern-based animation generation. Custom keyframes and tag-based frame markers. Cast targeting, layering options, and playback controls. Build your lighting plan by scene, timeline, and target selection. Apply pattern/show behaviour and test playback in preview before rollout. Tune behaviour safely without requiring immediate live hardware control. Playfield Playfield is the visual model of your playfield and hardware placement. Key features: Placement and sizing of playfield elements. Simulation preview for quick visual validation as you build. Hardware binding support for visual validation. Editing tools to maintain a clean machine map. Preview the playfield changes before applying them to your live machine workflow. Playfield event handling mirrors hardware flow, so triggers and responses behave consistently. Test trigger logic with immediate on-screen feedback that reflects hardware events. Useful reference context when authoring rules and lighting. Hardware Hardware manages the machine's physical I/O mapping and integration data used by runtime services. Key features: Mapping of switches, coils, lights, and related channels. Hardware profile and mapping management. Data used by bridge/runtime deployment steps. Foundation for safe, deterministic control at runtime. ESPLink ESPLink manages the Pi-to-ESP workflow and device-side compatibility checks. Key features: Connection and sync status visibility. Clear checks that Pi and ESP are on matching versions and manifest data before deployment. Workflow support for updating or synchronising device state. Integration point between authoring on Pi and execution on ESP32. Firmware Firmware supports firmware package handling and update flow for ESP targets. Key features: Firmware metadata and package handling. Updates from official Pinball CTL releases are available and listed here. Assisted update/deploy workflow hooks. Clear separation between host-side authoring and device runtime code. Useful for controlled release and maintenance tasks. Service Log Service Log focuses on service and maintenance history for managed services. Key features: Service and maintenance logging for users and engineers. Maintenance history for physical machine work such as cleaning and inspections. Records of hardware replacement and service actions over time. Helps teams track what was serviced, when it was done, and what changed. Helps confirm long-running service stability. Logs Logs provides direct access to application and bridge output for troubleshooting. Key features: Read runtime logs from the web UI. Inspect bridge and web logging without leaving the browser. Useful for identifying serial, protocol, or configuration issues. Supports day-to-day diagnostics during development and testing. Wi-Fi Wi-Fi shows and manages network connection details relevant to remote use. Key features: Current connection status and interface details. Wi-Fi setup/update controls. Helps confirm browser access and API reachability. Core tool for headless Pi deployments. Planned: Wi-Fi connected services will provide support for global leaderboards. Settings Settings contains installation-wide configuration options. Key features: Identity and general system settings. Security-related settings such as login credentials. Import/export style configuration workflows where supported. Central place for persistent environment-level options.","excerpt":"Features This page gives you a full overview of the main Pinball CTL features. Use the table for a quick summary, then use the detailed sections to understand what each area does. At-a-Glance Feature Table Name Purpose..."},{"slug":"1-user-guide/5-dashboard","path":"1-user-guide/5-dashboard.md","title":"Dashboard","order":5,"html":"<h1>Dashboard</h1><p>The Dashboard is your live status overview for Pinball CTL.</p><img src=\"./media/screenshot-dashboard.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/dashboard\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Dashboard feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>The Dashboard is designed as a fast health check page before you edit rules, lighting, hardware, or firmware.</p><h2>What This Feature Does</h2><p>It continuously polls runtime APIs and presents a single at-a-glance state for:</p><ul><li>connectivity</li><li>bridge/runtime processes</li><li>ESP state</li><li>sync status</li><li>dependency/tooling readiness</li></ul><h2>Live Refresh Behaviour</h2><p>Dashboard refreshes automatically in the background.</p><p>Key behaviour:</p><ul><li>Regular polling (about every 10 seconds).</li><li>Polling pauses when the page is hidden, then resumes when visible.</li><li>If bridge is running but ESP is not yet connected, quick retry mode is used.</li><li>Currency symbol values are loaded from Settings and applied to revenue cards.</li></ul><h2>Card-by-Card Reference</h2><h3>Wi-Fi</h3><p>Shows:</p><ul><li>interface</li><li>connected status (badge)</li><li>SSID</li><li>IP address</li><li>signal</li></ul><p>Use this to confirm remote browser access health.</p><h3>Bridge</h3><p>Shows:</p><ul><li>running/stopped status (badge)</li><li>detection source</li><li>PID</li></ul><p>Use this to verify bridge lifecycle state.</p><h3>Uptime</h3><p>Shows:</p><ul><li>since timestamp</li><li>human duration</li><li>raw seconds</li></ul><p>Useful for checking unexpected restarts.</p><h3>ESP32</h3><p>Shows:</p><ul><li>firmware</li><li>chip</li><li>ESP time</li><li>connected status</li><li>time sync status</li></ul><p>When ESP is connected, additional sync rows are shown:</p><ul><li>Rules Sync (state + last sync time)</li><li>Hardware Sync (state + last sync time)</li><li>Lighting Sync (state + last sync time)</li></ul><p>Sync badges:</p><ul><li><code>In Sync</code></li><li><code>Out of Sync</code></li><li><code>—</code> when unavailable</li></ul><h3>Dependencies</h3><p>Shows build/flash tooling and whether each dependency is available.</p><p>Each row includes:</p><ul><li>tool name</li><li>version (shortened in UI if long)</li><li><code>OK</code>/<code>Missing</code> badge</li></ul><h3>Gameplay / Revenue Snapshot / Player Flow / Machine</h3><p>These cards currently display demo/trend style values and machine summary context.</p><p>Use them as operational context alongside technical health cards.</p><h2>Typical Workflow</h2><ol><li>Open Dashboard first.</li><li>Confirm Wi-Fi, Bridge, and ESP are healthy.</li><li>Check sync status rows when ESP is connected.</li><li>If not healthy, move to the relevant feature:</li></ol><ul><li>Logs for runtime output</li><li>Hardware for mapping/sync</li><li>ESPLink for bridge/device controls</li></ul><h2>Example Checks</h2><h3>Pre-deployment check</h3><p>Before syncing rules or lighting:</p><ul><li>Bridge = Running</li><li>ESP Connected = Yes</li><li>Time Sync = OK</li><li>Dependencies = all <code>OK</code></li></ul><h3>Post-maintenance check</h3><p>After service work:</p><ul><li>Wi-Fi badge = Yes</li><li>Bridge PID populated</li><li>Uptime progressing normally</li><li>no unexpected sync regressions</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li><li><a href=\"#doc=1-user-guide/11-esplink\">ESPLink</a></li><li><a href=\"#doc=1-user-guide/14-logs\">Logs</a></li></ul>","plain":"Dashboard The Dashboard is your live status overview for Pinball CTL. The Dashboard is designed as a fast health check page before you edit rules, lighting, hardware, or firmware. What This Feature Does It continuously polls runtime APIs and presents a single at-a-glance state for: connectivity bridge/runtime processes ESP state sync status dependency/tooling readiness Live Refresh Behaviour Dashboard refreshes automatically in the background. Key behaviour: Regular polling about every 10 seconds . Polling pauses when the page is hidden, then resumes when visible. If bridge is running but ESP is not yet connected, quick retry mode is used. Currency symbol values are loaded from Settings and applied to revenue cards. Card-by-Card Reference Wi-Fi Shows: interface connected status badge SSID IP address signal Use this to confirm remote browser access health. Bridge Shows: running/stopped status badge detection source PID Use this to verify bridge lifecycle state. Uptime Shows: since timestamp human duration raw seconds Useful for checking unexpected restarts. ESP32 Shows: firmware chip ESP time connected status time sync status When ESP is connected, additional sync rows are shown: Rules Sync state + last sync time Hardware Sync state + last sync time Lighting Sync state + last sync time Sync badges: In Sync Out of Sync — when unavailable Dependencies Shows build/flash tooling and whether each dependency is available. Each row includes: tool name version shortened in UI if long OK/Missing badge Gameplay / Revenue Snapshot / Player Flow / Machine These cards currently display demo/trend style values and machine summary context. Use them as operational context alongside technical health cards. Typical Workflow Open Dashboard first. Confirm Wi-Fi, Bridge, and ESP are healthy. Check sync status rows when ESP is connected. If not healthy, move to the relevant feature: Logs for runtime output Hardware for mapping/sync ESPLink for bridge/device controls Example Checks Pre-deployment check Before syncing rules or lighting: Bridge = Running ESP Connected = Yes Time Sync = OK Dependencies = all OK Post-maintenance check After service work: Wi-Fi badge = Yes Bridge PID populated Uptime progressing normally no unexpected sync regressions Related Features Hardware ESPLink Logs","excerpt":"Dashboard The Dashboard is your live status overview for Pinball CTL. The Dashboard is designed as a fast health check page before you edit rules, lighting, hardware, or firmware. What This Feature Does It continuously..."},{"slug":"1-user-guide/7-rules","path":"1-user-guide/7-rules.md","title":"Rules","order":7,"html":"<h1>Rules</h1><p>Rules is the gameplay behaviour authoring feature.</p><img src=\"./media/screenshot-feature-rules.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/rules\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Rules feature overview\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>This page explains every main area of the Rules feature, what each control does, and how to build reliable setups.</p><h2>What This Feature Does</h2><p>Rules define what should happen when specific events occur.</p><p>At a high level:</p><ul><li>Triggers decide when a rule is considered.</li><li>Conditions decide whether a matching trigger is allowed to continue.</li><li>Actions define what happens when triggers and conditions pass.</li></ul><h2>Top Bar Controls</h2><p>At the top-right of the Rules page:</p><ul><li><code>Add Rule</code>: creates a new rule and opens it in the editor.</li><li><code>Sync Rules</code>: pushes current rules state to the ESP when required.</li><li><code>Save</code>: writes your current rule configuration to disk.</li></ul><p>Behaviour notes:</p><ul><li><code>Save</code> is enabled only when there are unsaved changes.</li><li>If you click <code>Sync Rules</code> with unsaved changes, you are prompted to save first.</li><li>If you leave the page with unsaved changes, the browser warns before unload.</li></ul><h2>Filters</h2><p>Under the header:</p><ul><li><code>All Tags</code> dropdown: filter rules by a specific tag.</li><li><code>Search name or notes…</code>: keyword filter over rule name/notes.</li><li><code>Clear filters</code>: shown only when a filter is active.</li></ul><h2>Sync Status</h2><p>The Sync button indicates whether the configuration is in sync with the ESP.</p><ul><li>If rules are not synced, the button shows a warning state (<code>Sync &lt;name&gt;</code> warning).</li><li>If rules are synced, the button shows the blue disabled OK state.</li></ul><p>If sync fails, check bridge connectivity and ESP link status first.</p><h2>Rules Table</h2><p>Each row in the table is one rule.</p><p>Columns:</p><ul><li>Expand/Collapse control</li><li>Enabled state dot</li><li>Name</li><li>Tags</li><li>Trigger count</li><li>Condition count</li><li>Action count</li><li>Delete button</li></ul><p>Row actions:</p><ul><li>Expand opens the full editor for that rule.</li><li>Enabled dot toggles active/inactive.</li><li>Delete removes the rule.</li></ul><h3>Expanded First Rule</h3><p>The screenshot below shows the first rule expanded, which is the baseline used in the tab walkthrough sections that follow.</p><img src=\"./media/screenshot-feature-rules-expanded.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"}]}' alt=\"First rule expanded in Rules editor\" style=\"width: 100%; max-width: 800px; height: auto;\"><h2>Rule Editor Tabs</h2><p>When a row is expanded, the rule editor appears with tabs:</p><ul><li>Metadata</li><li>Triggers</li><li>Conditions</li><li>Actions</li><li>Preview</li></ul><p>Validation badges:</p><ul><li>Red <code>!</code> badge can appear on <code>Triggers</code> and <code>Actions</code> tabs if required fields are missing.</li></ul><h2>Metadata Tab</h2><img src=\"./media/screenshot-feature-rules-tab-metadata.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#rules-tab-meta\",\"wait_for\":\"#rules-pane-meta.show.active\"}]}' alt=\"Rules metadata tab on first rule\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Metadata controls:</p><ul><li><code>Name</code> (required for a useful rule)</li><li><code>Enabled</code> checkbox (<code>Rule is active</code>)</li><li><code>Tags</code> list and <code>Add tag…</code> input</li><li><code>Notes</code> free text</li></ul><p>Tag behaviour:</p><ul><li>Tags appear as coloured chips.</li><li>Each tag chip has remove control.</li><li>New tags can be created inline.</li></ul><p>The metadata tab also shows a <code>Summary</code> block that previews the rule logic in plain text.</p><h2>Triggers Tab</h2><img src=\"./media/screenshot-feature-rules-tab-triggers.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#rules-tab-triggers\",\"wait_for\":\"#rules-pane-triggers.show.active\"}]}' alt=\"Rules triggers tab on first rule\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Triggers are organised as groups.</p><p>At trigger level:</p><ul><li><code>Add Trigger Group</code></li><li><code>Between trigger groups</code>: <code>ALL</code> or <code>ANY</code></li></ul><p>For each trigger group:</p><ul><li><code>Match within group</code>: <code>ALL</code> or <code>ANY</code></li><li><code>Window ms</code>: time window used to evaluate grouped trigger matches</li><li><code>Remove group</code></li><li><code>Add Trigger</code></li></ul><p>Each trigger has:</p><ul><li><code>Type</code>: <code>Hardware</code>, <code>System</code>, or <code>Custom</code></li></ul><h3>Hardware trigger options</h3><p>Fields:</p><ul><li><code>Hardware device</code></li><li><code>Hardware event</code></li></ul><p>The event list is based on selected hardware class and supports events such as:</p><ul><li>Button: <code>CLICKED</code>, <code>DOUBLE_CLICKED</code>, <code>HELD</code>, <code>PRESSED</code>, <code>RELEASED</code>, <code>REPEAT_WHILE_HELD</code></li><li>Switch/Opto: <code>CLOSED</code>, <code>OPENED</code>, <code>CHANGED</code>, <code>ACTIVE_FOR_MS</code>, <code>INACTIVE_FOR_MS</code></li><li>Tilt/Motion: <code>TILT_NUDGE</code>, <code>TILT_WARNING</code>, <code>TILT_TRIGGERED</code>, <code>LIFTED</code>, <code>DROPPED</code></li><li>NFC/RFID: <code>NFC_SCANNED</code>, <code>NFC_MATCHED</code></li></ul><p>Some hardware events expose extra numeric parameters, for example:</p><ul><li><code>windowMs</code></li><li><code>minMs</code></li><li><code>repeatMs</code></li></ul><p>A help button opens the <code>Hardware Event Key</code> modal with event purpose guidance.</p><h3>System trigger options</h3><p>Fields:</p><ul><li><code>Category</code></li><li><code>Event</code></li></ul><p>Categories include:</p><ul><li>Game</li><li>Credits</li><li>Modes</li><li>System</li><li>Bridge / Connectivity</li><li>Faults / Safety</li></ul><h3>Custom trigger options</h3><p>Fields:</p><ul><li><code>Event name</code></li></ul><p>Custom event names are normalised to uppercase underscore format (for example <code>START_GAME_REQUESTED</code>).</p><h2>Conditions Tab</h2><img src=\"./media/screenshot-feature-rules-tab-conditions.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#rules-tab-conditions\",\"wait_for\":\"#rules-pane-conditions.show.active\"}]}' alt=\"Rules conditions tab on first rule\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Conditions are optional checks that must pass before actions run.</p><p>At condition level:</p><ul><li><code>Add Condition Group</code></li><li><code>Between condition groups</code>: <code>ALL</code> or <code>ANY</code></li></ul><p>For each condition group:</p><ul><li><code>Match within group</code>: <code>ALL</code> or <code>ANY</code></li><li><code>Remove group</code></li><li><code>Add Condition</code></li></ul><p>Each condition starts with:</p><ul><li><code>Condition Type</code></li></ul><p>Supported condition types:</p><ul><li><code>Flag</code></li><li><code>Counter</code></li><li><code>Time Since Event</code></li><li><code>Device State</code></li></ul><h3>Flag condition options</h3><ul><li><code>Flag</code> (preset list or <code>Custom…</code>)</li><li><code>Operator</code> (currently equality)</li><li><code>Value</code> (<code>True</code>/<code>False</code>)</li></ul><p>If <code>Custom…</code> is selected, custom key input is shown.</p><h3>Counter condition options</h3><ul><li><code>Counter</code> (preset list, discovered counters, or <code>Custom…</code>)</li><li><code>Operator</code> (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li><li><code>Value</code> (number)</li></ul><p>Custom counter validation:</p><ul><li>must be uppercase letters, numbers, underscore</li><li>max length 32</li></ul><p>Known counters are shown as a hint below the selector.</p><h3>Time Since Event condition options</h3><ul><li><code>Event Type</code>: <code>System</code>, <code>Hardware</code>, or <code>Custom</code></li><li>event selector/input based on event type</li><li>comparison operator (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>)</li><li>time value in <code>ms</code></li></ul><h3>Device State condition options</h3><ul><li><code>Device</code></li><li><code>State</code></li></ul><p>Available state options depend on hardware type (for example coil active/inactive, switch open/closed, output high/low).</p><h2>Actions Tab</h2><img src=\"./media/screenshot-feature-rules-tab-actions.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#rules-tab-actions\",\"wait_for\":\"#rules-pane-actions.show.active\"}]}' alt=\"Rules actions tab on first rule\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Actions define what the rule does when triggers and conditions pass.</p><p>Controls:</p><ul><li><code>Add Action</code></li><li>per-action <code>Action</code> type selector</li><li>per-action <code>Remove</code></li></ul><p>Supported actions and options:</p><h3>Emit Event</h3><ul><li><code>Event Type</code>: <code>System</code> or <code>Custom</code></li><li>If <code>System</code>: <code>Category</code> and <code>Event</code></li><li>If <code>Custom</code>: free-text event input</li></ul><h3>Set Flag</h3><ul><li><code>Flag</code> (preset or custom)</li><li><code>Value</code> (<code>True</code> or <code>False</code>)</li></ul><h3>Set Counter</h3><ul><li><code>Counter</code> (preset, discovered, or custom)</li><li><code>Value</code></li></ul><h3>Increment Counter</h3><ul><li><code>Counter</code> (preset, discovered, or custom)</li><li><code>Delta</code></li></ul><h3>Pulse</h3><ul><li><code>Output / Coil</code></li><li><code>Duration (ms)</code></li></ul><h3>Set Output</h3><ul><li><code>Output / Coil</code></li><li><code>Value</code>: <code>HIGH</code>, <code>LOW</code>, or <code>PULSE</code></li><li>If <code>PULSE</code>: <code>Duration (ms)</code></li></ul><h3>Apply Lighting Scene</h3><ul><li><code>Scene</code></li><li><code>Start mode</code>: <code>Play immediately</code> or <code>Load paused</code></li><li><code>Start at</code>: <code>Scene start</code>, <code>Frame</code>, or <code>Tag</code></li><li>If <code>Frame</code>: <code>Frame</code> number (bounded by scene frame count)</li><li>If <code>Tag</code>: <code>Tag</code> selector based on scene tags</li></ul><h3>Stop Lighting Scene</h3><ul><li><code>Scene</code></li></ul><p>Planned actions (not general day-to-day options):</p><ul><li><code>LED Pattern</code></li><li><code>Delay</code></li></ul><p>These are treated as planned and are normally hidden unless already present in loaded data.</p><h2>Summary Tab</h2><img src=\"./media/screenshot-feature-rules-tab-summary.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"rules\\\"]\",\"wait_for\":\"#rules-list .rules-rule-toggle\"},{\"action\":\"click\",\"selector\":\"#rules-list .rules-rule-toggle\",\"wait_for\":\"#rules-editor:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#rules-tab-summary\",\"wait_for\":\"#rules-pane-summary.show.active\"}]}' alt=\"Rules summary tab on first rule\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>The summary tab shows the full selected rule as formatted JSON.</p><p>Use this for:</p><ul><li>checking exact stored structure</li><li>confirming grouped trigger/condition layout</li><li>verifying action payload fields before save/sync</li></ul><h2>Validation Rules You Should Know</h2><p>The editor flags missing essentials before save/sync.</p><p>Common trigger validation errors:</p><ul><li>no trigger groups</li><li>empty group items</li><li>missing hardware device/event</li><li>missing system event</li><li>missing custom event name</li></ul><p>Common action validation errors:</p><ul><li>missing action type</li><li>missing action target (event/flag/counter/device/scene)</li><li>invalid counter name format</li><li>missing counter value/delta where required</li><li>invalid lighting start frame/tag values</li></ul><h2>Practical Setup Examples</h2><h3>Example 1: Start game on button click</h3><p>Goal: clicking Start should emit a custom start request event.</p><p>Suggested setup:</p><ul><li>Trigger: Hardware -&gt; Start button -&gt; <code>CLICKED</code></li><li>Conditions: none</li><li>Action: <code>Emit Event</code> -&gt; <code>Custom</code> -&gt; <code>START_GAME_REQUESTED</code></li></ul><h3>Example 2: Award bonus only if game is active</h3><p>Goal: a lane switch hit increases bonus only during active ball play.</p><p>Suggested setup:</p><ul><li>Trigger: Hardware -&gt; Lane switch -&gt; <code>CLOSED</code></li><li>Conditions:</li><li>Flag <code>GAME_ACTIVE == True</code></li><li>Flag <code>BALL_IN_PLAY == True</code></li><li>Action: <code>Increment Counter</code> -&gt; <code>BONUS</code> delta <code>1</code></li></ul><h3>Example 3: Hold-to-repeat action with safety gate</h3><p>Goal: repeatedly fire an action while button is held, but only if enabled.</p><p>Suggested setup:</p><ul><li>Trigger: Hardware -&gt; Action button -&gt; <code>REPEAT_WHILE_HELD</code> with <code>repeatMs</code></li><li>Condition: Flag <code>ENABLED == True</code></li><li>Action: <code>Pulse</code> selected output with controlled duration</li></ul><h3>Example 4: Lighting scene at a tagged moment</h3><p>Goal: start a scene from a named point and keep it paused until another rule continues it.</p><p>Suggested setup:</p><ul><li>Trigger: System -&gt; Modes -&gt; <code>MODE_STARTED</code></li><li>Action: <code>Apply Lighting Scene</code></li><li>Scene: <code>mode_intro</code></li><li>Start mode: <code>Load paused</code></li><li>Start at: <code>Tag</code></li><li>Tag: <code>intro_start</code></li></ul><h3>Example 5: Fault response rule</h3><p>Goal: when fault is raised, immediately force warning output state.</p><p>Suggested setup:</p><ul><li>Trigger: System -&gt; Faults / Safety -&gt; <code>FAULT_RAISED</code></li><li>Conditions: none</li><li>Action: <code>Set Output</code> -&gt; warning output -&gt; <code>HIGH</code></li></ul><h2>Authoring Tips</h2><ul><li>Keep rule names explicit and short.</li><li>Use tags for mode grouping and quick filtering.</li><li>Prefer system events for lifecycle transitions and hardware events for player input.</li><li>Use condition groups to keep complex logic readable.</li><li>Validate in Preview before syncing to hardware.</li></ul><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/8-lighting\">Lighting</a></li><li><a href=\"#doc=1-user-guide/9-layout\">Playfield</a></li><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li></ul>","plain":"Rules Rules is the gameplay behaviour authoring feature. This page explains every main area of the Rules feature, what each control does, and how to build reliable setups. What This Feature Does Rules define what should happen when specific events occur. At a high level: Triggers decide when a rule is considered. Conditions decide whether a matching trigger is allowed to continue. Actions define what happens when triggers and conditions pass. Top Bar Controls At the top-right of the Rules page: Add Rule: creates a new rule and opens it in the editor. Sync Rules: pushes current rules state to the ESP when required. Save: writes your current rule configuration to disk. Behaviour notes: Save is enabled only when there are unsaved changes. If you click Sync Rules with unsaved changes, you are prompted to save first. If you leave the page with unsaved changes, the browser warns before unload. Filters Under the header: All Tags dropdown: filter rules by a specific tag. Search name or notes…: keyword filter over rule name/notes. Clear filters: shown only when a filter is active. Sync Status The Sync button indicates whether the configuration is in sync with the ESP. If rules are not synced, the button shows a warning state Sync warning . If rules are synced, the button shows the blue disabled OK state. If sync fails, check bridge connectivity and ESP link status first. Rules Table Each row in the table is one rule. Columns: Expand/Collapse control Enabled state dot Name Tags Trigger count Condition count Action count Delete button Row actions: Expand opens the full editor for that rule. Enabled dot toggles active/inactive. Delete removes the rule. Expanded First Rule The screenshot below shows the first rule expanded, which is the baseline used in the tab walkthrough sections that follow. Rule Editor Tabs When a row is expanded, the rule editor appears with tabs: Metadata Triggers Conditions Actions Preview Validation badges: Red ! badge can appear on Triggers and Actions tabs if required fields are missing. Metadata Tab Metadata controls: Name required for a useful rule Enabled checkbox Rule is active Tags list and Add tag… input Notes free text Tag behaviour: Tags appear as coloured chips. Each tag chip has remove control. New tags can be created inline. The metadata tab also shows a Summary block that previews the rule logic in plain text. Triggers Tab Triggers are organised as groups. At trigger level: Add Trigger Group Between trigger groups: ALL or ANY For each trigger group: Match within group: ALL or ANY Window ms: time window used to evaluate grouped trigger matches Remove group Add Trigger Each trigger has: Type: Hardware, System, or Custom Hardware trigger options Fields: Hardware device Hardware event The event list is based on selected hardware class and supports events such as: Button: CLICKED, DOUBLECLICKED, HELD, PRESSED, RELEASED, REPEATWHILEHELD Switch/Opto: CLOSED, OPENED, CHANGED, ACTIVEFORMS, INACTIVEFORMS Tilt/Motion: TILTNUDGE, TILTWARNING, TILTTRIGGERED, LIFTED, DROPPED NFC/RFID: NFCSCANNED, NFCMATCHED Some hardware events expose extra numeric parameters, for example: windowMs minMs repeatMs A help button opens the Hardware Event Key modal with event purpose guidance. System trigger options Fields: Category Event Categories include: Game Credits Modes System Bridge / Connectivity Faults / Safety Custom trigger options Fields: Event name Custom event names are normalised to uppercase underscore format for example STARTGAMEREQUESTED . Conditions Tab Conditions are optional checks that must pass before actions run. At condition level: Add Condition Group Between condition groups: ALL or ANY For each condition group: Match within group: ALL or ANY Remove group Add Condition Each condition starts with: Condition Type Supported condition types: Flag Counter Time Since Event Device State Flag condition options Flag preset list or Custom… Operator currently equality Value True/False If Custom… is selected, custom key input is shown. Counter condition options Counter preset list, discovered counters, or Custom… Operator ==, !=, , >= Value number Custom counter validation: must be uppercase letters, numbers, underscore max length 32 Known counters are shown as a hint below the selector. Time Since Event condition options Event Type: System, Hardware, or Custom event selector/input based on event type comparison operator >, >=, Actions define what the rule does when triggers and conditions pass. Controls: Add Action per-action Action type selector per-action Remove Supported actions and options: Emit Event Event Type: System or Custom If System: Category and Event If Custom: free-text event input Set Flag Flag preset or custom Value True or False Set Counter Counter preset, discovered, or custom Value Increment Counter Counter preset, discovered, or custom Delta Pulse Output / Coil Duration ms Set Output Output / Coil Value: HIGH, LOW, or PULSE If PULSE: Duration ms Apply Lighting Scene Scene Start mode: Play immediately or Load paused Start at: Scene start, Frame, or Tag If Frame: Frame number bounded by scene frame count If Tag: Tag selector based on scene tags Stop Lighting Scene Scene Planned actions not general day-to-day options : LED Pattern Delay These are treated as planned and are normally hidden unless already present in loaded data. Summary Tab The summary tab shows the full selected rule as formatted JSON. Use this for: checking exact stored structure confirming grouped trigger/condition layout verifying action payload fields before save/sync Validation Rules You Should Know The editor flags missing essentials before save/sync. Common trigger validation errors: no trigger groups empty group items missing hardware device/event missing system event missing custom event name Common action validation errors: missing action type missing action target event/flag/counter/device/scene invalid counter name format missing counter value/delta where required invalid lighting start frame/tag values Practical Setup Examples Example 1: Start game on button click Goal: clicking Start should emit a custom start request event. Suggested setup: Trigger: Hardware -> Start button -> CLICKED Conditions: none Action: Emit Event -> Custom -> STARTGAMEREQUESTED Example 2: Award bonus only if game is active Goal: a lane switch hit increases bonus only during active ball play. Suggested setup: Trigger: Hardware -> Lane switch -> CLOSED Conditions: Flag GAMEACTIVE == True Flag BALLINPLAY == True Action: Increment Counter -> BONUS delta 1 Example 3: Hold-to-repeat action with safety gate Goal: repeatedly fire an action while button is held, but only if enabled. Suggested setup: Trigger: Hardware -> Action button -> REPEATWHILEHELD with repeatMs Condition: Flag ENABLED == True Action: Pulse selected output with controlled duration Example 4: Lighting scene at a tagged moment Goal: start a scene from a named point and keep it paused until another rule continues it. Suggested setup: Trigger: System -> Modes -> MODESTARTED Action: Apply Lighting Scene Scene: modeintro Start mode: Load paused Start at: Tag Tag: introstart Example 5: Fault response rule Goal: when fault is raised, immediately force warning output state. Suggested setup: Trigger: System -> Faults / Safety -> FAULTRAISED Conditions: none Action: Set Output -> warning output -> HIGH` Authoring Tips Keep rule names explicit and short. Use tags for mode grouping and quick filtering. Prefer system events for lifecycle transitions and hardware events for player input. Use condition groups to keep complex logic readable. Validate in Preview before syncing to hardware. Related Features Lighting Playfield Hardware","excerpt":"Rules Rules is the gameplay behaviour authoring feature. This page explains every main area of the Rules feature, what each control does, and how to build reliable setups. What This Feature Does Rules define what should..."},{"slug":"1-user-guide/7.1-scoring","path":"1-user-guide/7.1-scoring.md","title":"Scoring","order":7,"html":"<h1>Scoring</h1><p>Scoring is the feature for designing how points are awarded during gameplay.</p><p>It supports fixed points, progressive hit ramps, and combo-based awards.</p><h2>Page Structure</h2><p>Scoring is split into three tabs:</p><ol><li><code>Base Points</code></li><li><code>Scoring Rules</code></li><li><code>Combos</code></li></ol><h2>Base Points Tab</h2><img src=\"./media/screenshot-feature-scoring.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/scoring\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Scoring base points tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Use this tab for straightforward score awards.</p><p>Each row configures:</p><ul><li>Source mode (<code>Hardware</code> or <code>Event</code>)</li><li>Trigger (hardware event type or event name)</li><li>Point value</li><li>Optional notes</li></ul><p>Typical uses:</p><ul><li>baseline points for common switch hits</li><li>points for named gameplay events</li><li>initial score model before advanced rules</li></ul><h2>Scoring Rules Tab</h2><img src=\"./media/screenshot-feature-scoring-scoring-rules.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/scoring\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Scoring rules tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Use this tab for progressive scoring logic.</p><p>Rules are collapsible cards that support:</p><ul><li>source and trigger setup</li><li>minimum hits</li><li>optional hit window (<code>min hits within ms</code>)</li><li>base points and points-per-hit scaling</li><li>bonus cap and cooloff behavior</li><li>optional emitted event</li></ul><p>Example ramp model:</p><ul><li><code>minHits = 1</code></li><li><code>basePoints = 20</code></li><li><code>pointsPerHit = 10</code></li><li><code>cooloffMs = 1500</code></li><li><code>cooloffStep = 1</code></li></ul><p>This rewards fast repeat hits while decaying value when play slows.</p><h2>Combos Tab</h2><img src=\"./media/screenshot-feature-scoring-combos.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/scoring\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Scoring combos tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Use this tab for multi-step scoring sequences.</p><p>Each combo supports:</p><ul><li>ordered or any-order matching</li><li>step time window</li><li>award points</li><li>optional temporary multiplier</li><li>optional emitted event</li></ul><p>Each step can use:</p><ul><li><code>Hardware</code>: button source + button event trigger</li><li><code>Event</code>: fired event name trigger</li></ul><p>Example ordered combo:</p><ul><li>step 1: left lane event</li><li>step 2: right lane event</li><li>step 3: top target event</li><li>award: 300 points</li><li>multiplier: x1.5 for 8 seconds</li></ul><h2>Save and Runtime Behavior</h2><ul><li>Changes stay staged until you click <code>Save Changes</code>.</li><li>Saved scoring config is persisted in instance data.</li><li>Runtime scoring listens to matching inputs and awards points in real time.</li></ul><h2>Integration Notes</h2><p>Scoring integrates with the event system.</p><p>This allows scoring to:</p><ul><li>react to events fired by other modules</li><li>emit events for Rules and Lighting</li><li>participate in mode-level gameplay flows</li></ul><h2>Practical Workflow</h2><ol><li>Add baseline rows in <code>Base Points</code>.</li><li>Add scaling rules in <code>Scoring Rules</code>.</li><li>Add sequence rewards in <code>Combos</code>.</li><li>Save and test in gameplay or emulation.</li><li>Tune values based on game feel.</li></ol><h2>Related Pages</h2><ul><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/8-lighting\">Lighting</a></li><li><a href=\"#doc=1-user-guide/9-layout\">Playfield</a></li></ul>","plain":"Scoring Scoring is the feature for designing how points are awarded during gameplay. It supports fixed points, progressive hit ramps, and combo-based awards. Page Structure Scoring is split into three tabs: Base Points Scoring Rules Combos Base Points Tab Use this tab for straightforward score awards. Each row configures: Source mode Hardware or Event Trigger hardware event type or event name Point value Optional notes Typical uses: baseline points for common switch hits points for named gameplay events initial score model before advanced rules Scoring Rules Tab Use this tab for progressive scoring logic. Rules are collapsible cards that support: source and trigger setup minimum hits optional hit window min hits within ms base points and points-per-hit scaling bonus cap and cooloff behavior optional emitted event Example ramp model: minHits = 1 basePoints = 20 pointsPerHit = 10 cooloffMs = 1500 cooloffStep = 1 This rewards fast repeat hits while decaying value when play slows. Combos Tab Use this tab for multi-step scoring sequences. Each combo supports: ordered or any-order matching step time window award points optional temporary multiplier optional emitted event Each step can use: Hardware: button source + button event trigger Event: fired event name trigger Example ordered combo: step 1: left lane event step 2: right lane event step 3: top target event award: 300 points multiplier: x1.5 for 8 seconds Save and Runtime Behavior Changes stay staged until you click Save Changes. Saved scoring config is persisted in instance data. Runtime scoring listens to matching inputs and awards points in real time. Integration Notes Scoring integrates with the event system. This allows scoring to: react to events fired by other modules emit events for Rules and Lighting participate in mode-level gameplay flows Practical Workflow Add baseline rows in Base Points. Add scaling rules in Scoring Rules. Add sequence rewards in Combos. Save and test in gameplay or emulation. Tune values based on game feel. Related Pages Rules Lighting Playfield","excerpt":"Scoring Scoring is the feature for designing how points are awarded during gameplay. It supports fixed points, progressive hit ramps, and combo-based awards. Page Structure Scoring is split into three tabs: Base Points..."},{"slug":"1-user-guide/8-lighting","path":"1-user-guide/8-lighting.md","title":"Lighting","order":8,"html":"<h1>Lighting</h1><p>Lighting is the scene authoring workflow for playfield effects and event-driven feedback.</p><p>It lets you build scenes, preview compiler output, and sync lighting data to ESP.</p><h2>Page Structure</h2><p>Lighting is split into two tabs:</p><ol><li><code>Stage</code></li><li><code>Fixtures</code></li></ol><h2>Stage Tab</h2><img src=\"./media/screenshot-feature-lighting-stage.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/lighting\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Lighting stage tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Stage is where scene playback and scene-level authoring happen.</p><p>Main areas:</p><ul><li>scene preview/stage area</li><li>scene selector and <code>Add Scene</code></li><li>options/editor card for selected scene</li><li>save and sync actions in the header</li></ul><p>Scene options include:</p><ul><li>title</li><li>duration (<code>seconds</code>, <code>minutes</code>, <code>frames</code>)</li><li>end behavior (<code>stop</code>, <code>repeat</code>, <code>bounce</code>)</li><li>pattern selection</li><li>priority and blend mode</li><li>cast scope/mask</li></ul><p>When pattern is <code>Custom Timeline</code>, timeline editing is available:</p><ul><li>frame scrubber and frame stepping</li><li>marker/tag pins</li><li>clear frame action</li><li>per-frame visual editing</li></ul><p>Playback behavior:</p><ul><li><code>Play</code> / <code>Stop</code> controls</li><li>preview follows compiled output path</li><li>updates reflect scene/pattern changes after compile</li></ul><h2>Fixtures Tab</h2><img src=\"./media/screenshot-feature-lighting-fixtures.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"lighting\\\"]\",\"wait_for\":\"#lighting-tab-fixtures\"},{\"action\":\"click\",\"selector\":\"#lighting-tab-fixtures\",\"wait_for\":\"#lighting-tab-fixtures-pane.show.active\"}]}' alt=\"Lighting fixtures tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Fixtures is focused on fixture inventory, targeting, and per-fixture context.</p><p>Use it to:</p><ul><li>review available fixtures</li><li>inspect fixture layout/type metadata</li><li>control cast targeting and selection scope</li><li>validate which fixtures a scene will affect</li></ul><p>This tab is useful when tuning cast masks or checking fixture coverage before sync.</p><h2>Top Actions</h2><ul><li><code>Add Scene</code>: create a new scene</li><li><code>Play</code> / <code>Stop</code>: preview selected scene</li><li><code>Sync Lighting</code>: compile and queue lighting sync to ESP</li><li><code>Save Changes</code>: persist local lighting config</li></ul><p>If local and ESP revisions differ, an out-of-sync warning is shown.</p><h2>Timeline Tags</h2><p>Frame tags are managed from the tag modal.</p><p>Rules:</p><ul><li>lowercase letters/numbers with <code>_</code> or <code>-</code></li><li>max length <code>64</code></li><li>unique per scene</li></ul><p>Tags are available in Rules <code>Apply Lighting Scene</code> actions (<code>Start at: Tag</code>).</p><h2>Save and Sync Workflow</h2><ol><li>Build or edit scene in <code>Stage</code>.</li><li>Validate cast/fixture targeting in <code>Fixtures</code>.</li><li>Click <code>Save Changes</code>.</li><li>Click <code>Sync Lighting</code>.</li></ol><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/9-layout\">Playfield</a></li><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li></ul>","plain":"Lighting Lighting is the scene authoring workflow for playfield effects and event-driven feedback. It lets you build scenes, preview compiler output, and sync lighting data to ESP. Page Structure Lighting is split into two tabs: Stage Fixtures Stage Tab Stage is where scene playback and scene-level authoring happen. Main areas: scene preview/stage area scene selector and Add Scene options/editor card for selected scene save and sync actions in the header Scene options include: title duration seconds, minutes, frames end behavior stop, repeat, bounce pattern selection priority and blend mode cast scope/mask When pattern is Custom Timeline, timeline editing is available: frame scrubber and frame stepping marker/tag pins clear frame action per-frame visual editing Playback behavior: Play / Stop controls preview follows compiled output path updates reflect scene/pattern changes after compile Fixtures Tab Fixtures is focused on fixture inventory, targeting, and per-fixture context. Use it to: review available fixtures inspect fixture layout/type metadata control cast targeting and selection scope validate which fixtures a scene will affect This tab is useful when tuning cast masks or checking fixture coverage before sync. Top Actions Add Scene: create a new scene Play / Stop: preview selected scene Sync Lighting: compile and queue lighting sync to ESP Save Changes: persist local lighting config If local and ESP revisions differ, an out-of-sync warning is shown. Timeline Tags Frame tags are managed from the tag modal. Rules: lowercase letters/numbers with or - max length 64 unique per scene Tags are available in Rules Apply Lighting Scene actions Start at: Tag . Save and Sync Workflow Build or edit scene in Stage. Validate cast/fixture targeting in Fixtures. Click Save Changes. Click Sync Lighting. Related Features Rules Playfield Hardware","excerpt":"Lighting Lighting is the scene authoring workflow for playfield effects and event-driven feedback. It lets you build scenes, preview compiler output, and sync lighting data to ESP. Page Structure Lighting is split into..."},{"slug":"1-user-guide/9-layout","path":"1-user-guide/9-layout.md","title":"Playfield","order":9,"html":"<h1>Playfield</h1><p>Playfield is the visual editor and runtime simulator for machine layout.</p><p>It provides a visual machine model for authoring, key binding, and event-response testing.</p><h2>Page Structure</h2><p>Playfield is split into two tabs:</p><ol><li><code>Stage</code></li><li><code>Options</code></li></ol><h2>Stage Tab</h2><img src=\"./media/screenshot-feature-layout-stage.png\" data-source='{\"url\":\"/login\",\"next_url\":\"/playfield\",\"dark_mode\":true,\"settle_ms\":320,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"}]}' alt=\"Playfield stage tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Stage contains the visual canvas and component editing workflow.</p><p>Main areas:</p><ul><li>playfield canvas</li><li>components card</li><li>component inspector (when a component is selected)</li><li>save action in the page header</li></ul><p>Component inspector supports:</p><ul><li>appearance and size controls</li><li>bound key capture/removal</li><li>key-down/key-up gesture mapping</li><li>trigger/action test controls</li><li>remove component action</li></ul><p>Drag and placement behavior:</p><ul><li>components move by drag on canvas</li><li>selected component is highlighted</li><li>updates persist after <code>Save Changes</code></li></ul><h2>Components Card</h2><p>The <code>Components</code> card is the hardware component list and quick layout control area.</p><p>Use it to:</p><ul><li>view discovered component groups (<code>Buttons</code>, <code>LEDs</code>, <code>Solenoids</code>, <code>Other</code>)</li><li>run <code>Auto Layout</code></li><li>run <code>Clear Layout</code></li><li>verify the hardware list is loaded before editing on-canvas positions</li></ul><img src=\"./media/screenshot-playfield-components-card.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"playfield\\\"]\",\"wait_for\":\"h1\"},{\"action\":\"click\",\"selector\":\"[data-emu-toggle=\\\"hw\\\"]\",\"wait_for\":\"[data-emu-panel=\\\"hw\\\"]:not(.d-none)\"}],\"target\":\".emu-side-col .emu-card:has([data-emu-toggle=\\\"hw\\\"])\" }' alt=\"Playfield Components card expanded\" style=\"width: 100%; max-width: 400px; height: auto;\"><h2>Component Inspector</h2><p>Select a component from the <code>Components</code> list to open and focus the <code>Component Inspector</code>.</p><p>Inspector usage:</p><ul><li>validate which element is selected</li><li>tune appearance, color, size, and rotation</li><li>capture and manage keyboard bindings</li><li>configure trigger/action test controls</li><li>remove a component if required</li></ul><p>The example below selects <code>Right Flipper Button</code> from the Components list and shows the populated inspector.</p><img src=\"./media/screenshot-playfield-component-inspector.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"playfield\\\"]\",\"wait_for\":\"#emu-stage-pane\"},{\"action\":\"click\",\"selector\":\"[data-emu-toggle=\\\"hw\\\"]\",\"wait_for\":\"[data-emu-panel=\\\"hw\\\"]:not(.d-none)\"},{\"action\":\"click\",\"selector\":\"#emu-buttons button.emu-chip:has-text(\\\"Right Flipper Button\\\")\",\"wait_for\":\"#emu-settings:not(.d-none)\"}],\"target\":\".emu-side-col .emu-card:has(#emu-selected-label)\"}' alt=\"Playfield Component Inspector with Right Flipper Button selected\" style=\"width: 100%; max-width: 400px; height: auto;\"><h2>Options Tab</h2><img src=\"./media/screenshot-feature-layout-options.png\" data-source='{\"url\":\"/login\",\"dark_mode\":true,\"settle_ms\":420,\"click\":[{\"action\":\"type\",\"selector\":\"input[name=\\\"username\\\"]\",\"value\":\"admin\"},{\"action\":\"type\",\"selector\":\"input[name=\\\"password\\\"]\",\"value\":\"password\"},{\"action\":\"click\",\"selector\":\"button[type=\\\"submit\\\"]\",\"wait_for\":\"[data-menu-toggle]\"},{\"action\":\"click\",\"selector\":\"[data-menu-toggle]\",\"wait_for\":\"body.flood-open\"},{\"action\":\"click\",\"selector\":\"[data-nav-link][data-module-name=\\\"playfield\\\"]\",\"wait_for\":\"#emu-options-tab\"},{\"action\":\"click\",\"selector\":\"#emu-options-tab\",\"wait_for\":\"#emu-options-pane.show.active\"}]}' alt=\"Playfield options tab\" style=\"width: 100%; max-width: 800px; height: auto;\"><p>Options contains layout-level controls.</p><p>Primary controls:</p><ul><li>width</li><li>height</li><li>ratio display</li></ul><p>Layout actions:</p><ul><li><code>Auto Layout</code></li><li><code>Clear Layout</code></li></ul><p>Use this tab to quickly regenerate/reset placement without editing each component manually.</p><h2>Keyboard Binding System</h2><p>Binding flow:</p><ol><li>Select a component in <code>Stage</code>.</li><li>Click <code>Capture</code> in inspector.</li><li>Press a key.</li><li>Configure key-down and key-up gestures.</li></ol><p>This allows interaction testing without physical hardware input.</p><h2>Event and Trigger Testing</h2><p>Playfield can fire bound events and show response state visually.</p><p>Common uses:</p><ul><li>validate rule-trigger mappings</li><li>test event-driven reactions</li><li>verify component linkage behavior</li></ul><h2>Save Workflow</h2><p>Recommended flow:</p><ol><li>Arrange components in <code>Stage</code>.</li><li>Tune layout-level values in <code>Options</code>.</li><li>Test key bindings and events.</li><li>Click <code>Save Changes</code>.</li></ol><h2>Related Features</h2><ul><li><a href=\"#doc=1-user-guide/7-rules\">Rules</a></li><li><a href=\"#doc=1-user-guide/8-lighting\">Lighting</a></li><li><a href=\"#doc=1-user-guide/10-hardware\">Hardware</a></li></ul>","plain":"Playfield Playfield is the visual editor and runtime simulator for machine layout. It provides a visual machine model for authoring, key binding, and event-response testing. Page Structure Playfield is split into two tabs: Stage Options Stage Tab Stage contains the visual canvas and component editing workflow. Main areas: playfield canvas components card component inspector when a component is selected save action in the page header Component inspector supports: appearance and size controls bound key capture/removal key-down/key-up gesture mapping trigger/action test controls remove component action Drag and placement behavior: components move by drag on canvas selected component is highlighted updates persist after Save Changes Components Card The Components card is the hardware component list and quick layout control area. Use it to: view discovered component groups Buttons, LEDs, Solenoids, Other run Auto Layout run Clear Layout verify the hardware list is loaded before editing on-canvas positions Component Inspector Select a component from the Components list to open and focus the Component Inspector. Inspector usage: validate which element is selected tune appearance, color, size, and rotation capture and manage keyboard bindings configure trigger/action test controls remove a component if required The example below selects Right Flipper Button from the Components list and shows the populated inspector. Options Tab Options contains layout-level controls. Primary controls: width height ratio display Layout actions: Auto Layout Clear Layout Use this tab to quickly regenerate/reset placement without editing each component manually. Keyboard Binding System Binding flow: Select a component in Stage. Click Capture in inspector. Press a key. Configure key-down and key-up gestures. This allows interaction testing without physical hardware input. Event and Trigger Testing Playfield can fire bound events and show response state visually. Common uses: validate rule-trigger mappings test event-driven reactions verify component linkage behavior Save Workflow Recommended flow: Arrange components in Stage. Tune layout-level values in Options. Test key bindings and events. Click Save Changes. Related Features Rules Lighting Hardware","excerpt":"Playfield Playfield is the visual editor and runtime simulator for machine layout. It provides a visual machine model for authoring, key binding, and event-response testing. Page Structure Playfield is split into two..."},{"slug":"1-user-guide/99-supported-components","path":"1-user-guide/99-supported-components.md","title":"Supported Components","order":99,"html":"<h1>Supported Components</h1><p>This page tracks hardware and platform support for Pinball CTL.</p><p>At this stage, support is naturally based on the equipment used during development and testing.</p><h2>Support Levels</h2><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Status</th>        <th>Meaning</th>      </tr>    </thead>    <tbody>      <tr><td>✅ Supported</td><td>Used and verified in this project</td></tr>      <tr><td>⚠️ Limited</td><td>Partially tested or expected to work, but not fully validated</td></tr>      <tr><td>❓ Unknown</td><td>Not tested yet</td></tr>    </tbody>  </table></div><h2>Core Platform</h2><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Component</th>        <th>Status</th>        <th>Notes</th>      </tr>    </thead>    <tbody>      <tr><td>Raspberry Pi 5</td><td>✅ Supported</td><td>Main runtime platform</td></tr>      <tr><td>Raspberry Pi OS (64-bit)</td><td>✅ Supported</td><td>Recommended for Pi 5</td></tr>      <tr><td>macOS (development host)</td><td>✅ Supported</td><td>Used for development workflow</td></tr>      <tr><td>Other Linux distributions</td><td>⚠️ Limited</td><td>Likely workable but not formally tested</td></tr>      <tr><td>Windows development host</td><td>❓ Unknown</td><td>Not validated yet</td></tr>    </tbody>  </table></div><h2>Control Hardware</h2><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Component</th>        <th>Status</th>        <th>Notes</th>      </tr>    </thead>    <tbody>      <tr><td>ESP32-S3 board used by this project</td><td>✅ Supported</td><td>Primary real-time controller</td></tr>      <tr><td>Other ESP32 variants</td><td>⚠️ Limited</td><td>May require firmware/protocol adjustments</td></tr>      <tr><td>USB serial bridge (Pi &lt;-&gt; ESP32)</td><td>✅ Supported</td><td>Required for normal operation</td></tr>    </tbody>  </table></div><h2>I/O Expansion and Devices</h2><div class=\"manual-table-wrap\">  <table class=\"manual-table\">    <thead>      <tr>        <th>Component</th>        <th>Status</th>        <th>Notes</th>      </tr>    </thead>    <tbody>      <tr><td>MCP23017 I2C expanders</td><td>✅ Supported</td><td>Used in current hardware stack</td></tr>      <tr><td>Basic switches/buttons</td><td>✅ Supported</td><td>Via mapped input flow</td></tr>      <tr><td>Solenoids/coils</td><td>✅ Supported</td><td>Safety controls expected on ESP side</td></tr>      <tr><td>RGB strips (configured in mapping)</td><td>✅ Supported</td><td>Supported in current lighting flow</td></tr>      <tr><td>Other lighting drivers/chipsets</td><td>⚠️ Limited</td><td>Depends on firmware support</td></tr>    </tbody>  </table></div><h2>Notes</h2><ul><li>This list will grow as more boards and devices are tested.</li><li>If your setup differs from the list above, Pinball CTL may still work, but behaviour can vary.</li></ul>","plain":"Supported Components This page tracks hardware and platform support for Pinball CTL. At this stage, support is naturally based on the equipment used during development and testing. Support Levels Status Meaning ✅ Supported Used and verified in this project ⚠️ Limited Partially tested or expected to work, but not fully validated ❓ Unknown Not tested yet Core Platform Component Status Notes Raspberry Pi 5 ✅ Supported Main runtime platform Raspberry Pi OS 64-bit ✅ Supported Recommended for Pi 5 macOS development host ✅ Supported Used for development workflow Other Linux distributions ⚠️ Limited Likely workable but not formally tested Windows development host ❓ Unknown Not validated yet Control Hardware Component Status Notes ESP32-S3 board used by this project ✅ Supported Primary real-time controller Other ESP32 variants ⚠️ Limited May require firmware/protocol adjustments USB serial bridge Pi &lt;-&gt; ESP32 ✅ Supported Required for normal operation I/O Expansion and Devices Component Status Notes MCP23017 I2C expanders ✅ Supported Used in current hardware stack Basic switches/buttons ✅ Supported Via mapped input flow Solenoids/coils ✅ Supported Safety controls expected on ESP side RGB strips configured in mapping ✅ Supported Supported in current lighting flow Other lighting drivers/chipsets ⚠️ Limited Depends on firmware support Notes This list will grow as more boards and devices are tested. If your setup differs from the list above, Pinball CTL may still work, but behaviour can vary.","excerpt":"Supported Components This page tracks hardware and platform support for Pinball CTL. At this stage, support is naturally based on the equipment used during development and testing. Support Levels Status Meaning ✅..."},{"slug":"2-technical-notes/README","path":"2-technical-notes/README.md","title":"Technical Section","order":10000,"html":"<h1>Technical Section</h1><h2>Core Technical Docs</h2><ul><li><a href=\"#doc=2-technical-notes/architecture\">Architecture</a></li><li><a href=\"#doc=2-technical-notes/bridge-protocol\">Bridge Protocol</a></li><li><a href=\"#doc=2-technical-notes/bridge-event-flow-and-throughput\">Bridge Event Flow And Throughput</a></li><li><a href=\"#doc=2-technical-notes/event-manager-entry-points\">Event Manager Entry Points</a></li><li><a href=\"#doc=2-technical-notes/event-manager-handlers-and-current-state\">Event Manager Handlers And Current State</a></li><li><a href=\"#doc=2-technical-notes/modules/README\">Technical Module Reference</a></li></ul><h2>Discussions / Deep Dives</h2><ul><li><a href=\"discussions/README.md\">Technical Discussions Index</a></li><li><a href=\"discussions/EMULATOR.md\">EMULATOR</a></li><li><a href=\"discussions/ESPLink.md\">ESPLink</a></li><li><a href=\"discussions/EVENT_ENGINE.md\">EVENT_ENGINE</a></li><li><a href=\"discussions/LIGHTING.md\">LIGHTING</a></li><li><a href=\"discussions/SYSTEM_CONTEXT.md\">SYSTEM_CONTEXT</a></li></ul><h2>Maintainer / Operations</h2><ul><li><a href=\"discussions/RUNNING.md\">RUNNING</a></li><li><a href=\"discussions/MAINTAINER.md\">MAINTAINER</a></li><li><a href=\"discussions/PACKAGING.md\">PACKAGING</a></li></ul>","plain":"Technical Section Core Technical Docs Architecture Bridge Protocol Bridge Event Flow And Throughput Event Manager Entry Points Event Manager Handlers And Current State Technical Module Reference Discussions / Deep Dives Technical Discussions Index EMULATOR ESPLink EVENTENGINE LIGHTING SYSTEMCONTEXT Maintainer / Operations RUNNING MAINTAINER PACKAGING","excerpt":"Technical Section Core Technical Docs Architecture Bridge Protocol Bridge Event Flow And Throughput Event Manager Entry Points Event Manager Handlers And Current State Technical Module Reference Discussions / Deep Dives..."},{"slug":"2-technical-notes/architecture","path":"2-technical-notes/architecture.md","title":"Technical Architecture","order":10000,"html":"<h1>Technical Architecture</h1><p>The stack is split between Pi orchestration and ESP runtime.</p><h2>Pi (Authoring + Orchestration)</h2><ul><li>Flask web modules</li><li>Bridge daemon</li><li>Persistent user configuration</li></ul><h2>ESP (Runtime + Safety)</h2><ul><li>Real-time switch/coils/LED processing</li><li>Safety enforcement</li><li>Fault handling</li></ul><h2>Data Flow</h2><ul><li>User edits rules/config in UI.</li><li>Pi persists and compiles state.</li><li>Pi deploys framed JSON commands to ESP bridge.</li></ul>","plain":"Technical Architecture The stack is split between Pi orchestration and ESP runtime. Pi Authoring + Orchestration Flask web modules Bridge daemon Persistent user configuration ESP Runtime + Safety Real-time switch/coils/LED processing Safety enforcement Fault handling Data Flow User edits rules/config in UI. Pi persists and compiles state. Pi deploys framed JSON commands to ESP bridge.","excerpt":"Technical Architecture The stack is split between Pi orchestration and ESP runtime. Pi Authoring + Orchestration Flask web modules Bridge daemon Persistent user configuration ESP Runtime + Safety Real-time..."},{"slug":"2-technical-notes/bridge-event-flow-and-throughput","path":"2-technical-notes/bridge-event-flow-and-throughput.md","title":"Bridge Event Flow And Throughput","order":10000,"html":"<h1>Bridge Event Flow And Throughput</h1><p>This page documents how Pi, Bridge, and ESP communicate in the current framed-JSON architecture, plus measured throughput from soak testing on February 6, 2026.</p><p><img alt=\"Pi-Bridge-ESP event flow\" src=\"./assets/pi-bridge-esp-event-flow.svg\"></p><h2>High-Level Model</h2><ul><li>Pi Web/API is the orchestration layer.</li><li>Bridge daemon is the single transport boundary between Pi and ESP.</li><li>ESP is the real-time runtime/safety authority.</li></ul><p>All Pi &lt;-&gt; ESP traffic goes through the bridge using framed JSON:</p><ul><li>4-byte big-endian length header</li><li>UTF-8 JSON payload</li><li>No newline/line-based command path</li></ul><h2>Message Types</h2><h2>Response-required RPC (request/response)</h2><p>Used for control/status requests where caller expects a specific response.</p><p>Examples:</p><ul><li><code>ECHO</code></li><li><code>GET_INFO</code></li><li><code>GET_FS_STATUS</code></li><li><code>FS_LIST</code></li><li><code>FS_MANIFEST_GET</code></li><li><code>SET_RULES</code> (with <code>RULES_STATUS</code> response)</li></ul><p>These use <code>reqId</code> correlation through bridge pending-response handling.</p><h2>Fire-and-forget events (high-volume, no per-event response)</h2><p>Used for fast event publication where acknowledgement is not required.</p><p>Examples:</p><ul><li><code>EVENT_FIRE</code> from Pi -&gt; ESP</li><li><code>EVT</code> stream from ESP -&gt; Pi</li></ul><p>This path is intended for high-frequency gameplay telemetry/event flow.</p><h2>Event stream control/status</h2><p>Used for load/soak testing and controlled event burst runs.</p><p>Examples:</p><ul><li><code>EVT_STREAM_START</code></li><li><code>EVT_STREAM_STATUS</code></li><li><code>EVT_STREAM_DONE</code></li></ul><h2>Runtime Notes</h2><ul><li>ESP enforces runtime safety and local real-time behavior.</li><li>Bridge handles framing, req/resp correlation, and event publication into Pi handlers.</li><li>UI responsiveness improves when high-rate event traffic is not over-logged.</li></ul><h2>Throughput Results (Soak)</h2><p>Representative run:</p><p>Command:</p><pre><code>./utils/event-soak.sh --rpc-count 100 --fire-count 10000 --fire-batch 1000 --stream-count 10000 --stream-rate 800 --stream-timeout 120</code></pre><p>Results:</p><ul><li>Phase 1 (Pi-&gt;ESP RPC <code>EVENT</code> w/ <code>EVENT_ACK</code>): <code>22.81 req/s</code></li><li>Phase 1 latency: <code>43.8 ms avg</code>, <code>49.9 ms max</code></li><li>Phase 1b (Pi-&gt;ESP <code>EVENT_FIRE</code>): <code>10000/10000 seen</code>, <code>0 lost</code></li><li>Phase 1b throughput: <code>543.60 evt/s</code> end-to-end (<code>598.84 evt/s</code> enqueue rate)</li><li>Phase 2 (ESP-&gt;Pi stream at target <code>800</code>): <code>sent=10000</code>, <code>dropped=0</code>, <code>rx_delta=10000</code></li><li>Phase 2 measured rate: <code>551.29 evt/s</code></li></ul><p>Higher target run:</p><p>Command:</p><pre><code>./utils/event-soak.sh --rpc-count 100 --fire-count 10000 --fire-batch 1000 --stream-count 10000 --stream-rate 1200 --stream-timeout 120</code></pre><p>Results:</p><ul><li>Phase 2: <code>sent=10000</code>, <code>dropped=0</code>, <code>rx_delta=10000</code></li><li>Measured stream rate: <code>542.95 evt/s</code></li></ul><p>Interpretation:</p><ul><li>Current practical ESP-&gt;Pi sustained ceiling is around <code>~540-550 evt/s</code> in this environment.</li><li>System saturates cleanly at higher requested rates (no firmware-reported drops in these runs).</li></ul><h2>Practical Operating Guidance</h2><ul><li>Keep response-required RPC for control/status only.</li><li>Use fire-and-forget event flow for high-frequency gameplay traffic.</li><li>Keep ultra-latency-critical reactions local on ESP.</li><li>Send summarized/batched telemetry upstream to Pi where appropriate.</li></ul><p>Conservative planning targets:</p><ul><li>Sustained design target: <code>&lt;= 350-400 evt/s</code></li><li>Burst target: up to <code>~500 evt/s</code></li></ul><p>This preserves headroom for background work and future rule complexity.</p>","plain":"Bridge Event Flow And Throughput This page documents how Pi, Bridge, and ESP communicate in the current framed-JSON architecture, plus measured throughput from soak testing on February 6, 2026. Pi-Bridge-ESP event flow High-Level Model Pi Web/API is the orchestration layer. Bridge daemon is the single transport boundary between Pi and ESP. ESP is the real-time runtime/safety authority. All Pi ESP traffic goes through the bridge using framed JSON: 4-byte big-endian length header UTF-8 JSON payload No newline/line-based command path Message Types Response-required RPC request/response Used for control/status requests where caller expects a specific response. Examples: ECHO GETINFO GETFSSTATUS FSLIST FSMANIFESTGET SETRULES with RULESSTATUS response These use reqId correlation through bridge pending-response handling. Fire-and-forget events high-volume, no per-event response Used for fast event publication where acknowledgement is not required. Examples: EVENTFIRE from Pi -> ESP EVT stream from ESP -> Pi This path is intended for high-frequency gameplay telemetry/event flow. Event stream control/status Used for load/soak testing and controlled event burst runs. Examples: EVTSTREAMSTART EVTSTREAMSTATUS EVTSTREAMDONE Runtime Notes ESP enforces runtime safety and local real-time behavior. Bridge handles framing, req/resp correlation, and event publication into Pi handlers. UI responsiveness improves when high-rate event traffic is not over-logged. Throughput Results Soak Representative run: Command: Results: Phase 1 Pi->ESP RPC EVENT w/ EVENTACK : 22.81 req/s Phase 1 latency: 43.8 ms avg, 49.9 ms max Phase 1b Pi->ESP EVENTFIRE : 10000/10000 seen, 0 lost Phase 1b throughput: 543.60 evt/s end-to-end 598.84 evt/s enqueue rate Phase 2 ESP->Pi stream at target 800 : sent=10000, dropped=0, rxdelta=10000 Phase 2 measured rate: 551.29 evt/s Higher target run: Command: Results: Phase 2: sent=10000, dropped=0, rxdelta=10000 Measured stream rate: 542.95 evt/s Interpretation: Current practical ESP->Pi sustained ceiling is around ~540-550 evt/s in this environment. System saturates cleanly at higher requested rates no firmware-reported drops in these runs . Practical Operating Guidance Keep response-required RPC for control/status only. Use fire-and-forget event flow for high-frequency gameplay traffic. Keep ultra-latency-critical reactions local on ESP. Send summarized/batched telemetry upstream to Pi where appropriate. Conservative planning targets: Sustained design target: <= 350-400 evt/s Burst target: up to ~500 evt/s This preserves headroom for background work and future rule complexity.","excerpt":"Bridge Event Flow And Throughput This page documents how Pi, Bridge, and ESP communicate in the current framed-JSON architecture, plus measured throughput from soak testing on February 6, 2026. Pi-Bridge-ESP event flow..."},{"slug":"2-technical-notes/bridge-protocol","path":"2-technical-notes/bridge-protocol.md","title":"Bridge Protocol","order":10000,"html":"<h1>Bridge Protocol</h1><p>Bridge communication is framed JSON only.</p><h2>Frame Format</h2><ul><li>4-byte big-endian payload length</li><li>UTF-8 JSON payload</li></ul><h2>Notes</h2><ul><li>No line-based parsing.</li><li>Host commands and responses are framed.</li><li>Keep command payloads explicit and version-friendly.</li></ul>","plain":"Bridge Protocol Bridge communication is framed JSON only. Frame Format 4-byte big-endian payload length UTF-8 JSON payload Notes No line-based parsing. Host commands and responses are framed. Keep command payloads explicit and version-friendly.","excerpt":"Bridge Protocol Bridge communication is framed JSON only. Frame Format 4-byte big-endian payload length UTF-8 JSON payload Notes No line-based parsing. Host commands and responses are framed. Keep command payloads..."},{"slug":"2-technical-notes/event-manager-entry-points","path":"2-technical-notes/event-manager-entry-points.md","title":"Event Manager Entry Points (Requirement + Implementation)","order":10000,"html":"<h1>Event Manager Entry Points (Requirement + Implementation)</h1><p>This page captures the requirement for the event manager/handler layer and the current concrete hook points in the codebase.</p><p>For the current registered handler inventory and runtime status, see:</p><ul><li><a href=\"#doc=2-technical-notes/event-manager-handlers-and-current-state\">Pi Event Manager: Handlers and Current State</a></li></ul><h2>Requirement</h2><p>The event manager must run against deployed rules (<code>rules.pd</code>) and use a clear event boundary on both sides:</p><ul><li>Pi side:</li><li>orchestration, scoring/state, UI and non-real-time logic</li><li>publishes commands/events to ESP only through the bridge</li><li>ESP side:</li><li>real-time runtime and safety enforcement</li><li>executes immediate hardware logic locally</li><li>publishes telemetry/events upstream to Pi</li></ul><p>Transport requirement:</p><ul><li>Frames-only JSON protocol</li><li>No line-based command path</li><li><code>reqId</code> correlation for response-required RPC</li><li>fire-and-forget path for high-volume events</li></ul><h2>Implementation: Single Hook Points</h2><h2>1) Pi -&gt; ESP command/event ingress (Bridge TX)</h2><p>Bridge receives RPC/socket commands and funnels them through a single framed send path:</p><ul><li>Command intake and dispatch loop:</li><li><code>src/pinballctl/bridge/daemon.py:1201</code></li><li><code>src/pinballctl/bridge/daemon.py:1231</code></li><li>Single serial send function:</li><li><code>src/pinballctl/bridge/daemon.py:224</code></li></ul><p>This is the Pi-side hook for outbound event manager integration.</p><h2>2) ESP inbound framed command ingress</h2><p>All framed inbound serial data is parsed in <code>System::loop()</code> and forwarded to protocol handler:</p><ul><li>Framed RX parse + dispatch:</li><li><code>src/firmware/src/System.cpp:107</code></li><li><code>src/firmware/src/System.cpp:174</code></li></ul><p>Then protocol-level event commands are handled centrally:</p><ul><li><code>EVENT</code>, <code>EVENT_FIRE</code>, <code>EVENT_STATS</code>, <code>EVT_STREAM_*</code>:</li><li><code>src/firmware/src/protocol/ProtocolHandler.cpp:420</code></li></ul><p>This is the ESP-side hook for rules/event handler evaluation.</p><h2>3) ESP -&gt; Pi event ingress (Bridge RX + bus publish)</h2><p>All decoded ESP JSON messages are routed through one handler:</p><ul><li>Message router:</li><li><code>src/pinballctl/bridge/daemon.py:1324</code></li></ul><p>Event publishing to Pi bus is centralized there:</p><ul><li>Bus emit for <code>EVT</code>/<code>EVENT</code>:</li><li><code>src/pinballctl/bridge/daemon.py:1379</code></li></ul><p>This is the Pi-side inbound hook for event handler registration/execution.</p><h2>Practical Integration Plan</h2><ol><li>Keep transport layer unchanged (already validated by soak tests).</li><li>Add rule-evaluation calls only at these hook points.</li><li>Keep response-required RPC and fire-and-forget event paths distinct.</li><li>Keep ESP local-first for real-time actions; only publish required upstream events.</li><li>Preserve <code>reqId</code>/sequence correlation and metrics for observability.</li></ol><p>This keeps implementation centralized and avoids protocol/handler scattering across modules.</p>","plain":"Event Manager Entry Points Requirement + Implementation This page captures the requirement for the event manager/handler layer and the current concrete hook points in the codebase. For the current registered handler inventory and runtime status, see: Pi Event Manager: Handlers and Current State Requirement The event manager must run against deployed rules rules.pd and use a clear event boundary on both sides: Pi side: orchestration, scoring/state, UI and non-real-time logic publishes commands/events to ESP only through the bridge ESP side: real-time runtime and safety enforcement executes immediate hardware logic locally publishes telemetry/events upstream to Pi Transport requirement: Frames-only JSON protocol No line-based command path reqId correlation for response-required RPC fire-and-forget path for high-volume events Implementation: Single Hook Points 1 Pi -> ESP command/event ingress Bridge TX Bridge receives RPC/socket commands and funnels them through a single framed send path: Command intake and dispatch loop: src/pinballctl/bridge/daemon.py:1201 src/pinballctl/bridge/daemon.py:1231 Single serial send function: src/pinballctl/bridge/daemon.py:224 This is the Pi-side hook for outbound event manager integration. 2 ESP inbound framed command ingress All framed inbound serial data is parsed in System::loop and forwarded to protocol handler: Framed RX parse + dispatch: src/firmware/src/System.cpp:107 src/firmware/src/System.cpp:174 Then protocol-level event commands are handled centrally: EVENT, EVENTFIRE, EVENTSTATS, EVTSTREAM: src/firmware/src/protocol/ProtocolHandler.cpp:420 This is the ESP-side hook for rules/event handler evaluation. 3 ESP -> Pi event ingress Bridge RX + bus publish All decoded ESP JSON messages are routed through one handler: Message router: src/pinballctl/bridge/daemon.py:1324 Event publishing to Pi bus is centralized there: Bus emit for EVT/EVENT: src/pinballctl/bridge/daemon.py:1379 This is the Pi-side inbound hook for event handler registration/execution. Practical Integration Plan Keep transport layer unchanged already validated by soak tests . Add rule-evaluation calls only at these hook points. Keep response-required RPC and fire-and-forget event paths distinct. Keep ESP local-first for real-time actions; only publish required upstream events. Preserve reqId/sequence correlation and metrics for observability. This keeps implementation centralized and avoids protocol/handler scattering across modules.","excerpt":"Event Manager Entry Points Requirement + Implementation This page captures the requirement for the event manager/handler layer and the current concrete hook points in the codebase. For the current registered handler..."},{"slug":"2-technical-notes/event-manager-handlers-and-current-state","path":"2-technical-notes/event-manager-handlers-and-current-state.md","title":"Pi Event Manager: Handlers and Current State","order":10000,"html":"<h1>Pi Event Manager: Handlers and Current State</h1><p>This document describes the current Pi-side Event Manager implementation, including all registered handler routes and current behavior.</p><h2>Scope</h2><p>Pi Event Manager is implemented in:</p><ul><li><code>src/pinballctl/events/manager.py</code></li></ul><p>It is currently wired at two ingress points:</p><ul><li>API-origin events:</li><li><code>POST /api/events/fire</code></li><li>implementation: <code>src/pinballctl/app/modules/events/api.py</code></li><li>Bridge-origin events from ESP (<code>EVT</code>/<code>EVENT</code>):</li><li>implementation: <code>src/pinballctl/bridge/daemon.py</code></li></ul><h2>Handler Model</h2><p>Event Manager uses route keys and registered handlers:</p><ul><li><code>system:&lt;EVENT&gt;</code></li><li><code>hardware:&lt;deviceClass&gt;:&lt;eventType&gt;</code></li><li><code>custom</code></li><li><code>event:&lt;name&gt;</code> (dynamic route key)</li><li><code>all</code> (global route key)</li></ul><p>Current registered default handlers are explicit no-op stubs (<code>_NoopHandler</code>) for all rules-defined system and hardware route keys plus <code>custom</code>.</p><p>This gives a stable, centralized interface now, with business logic to be added incrementally later.</p><h2>Current Registered Handlers</h2><p>The manager currently auto-registers these route keys from rules registry:</p><h3>System handlers</h3><ul><li><code>system:GAME_STARTED</code></li><li><code>system:GAME_ENDED</code></li><li><code>system:BALL_STARTED</code></li><li><code>system:BALL_ENDED</code></li><li><code>system:PLAYER_ADDED</code></li><li><code>system:CREDITS_CHANGED</code></li><li><code>system:HAS_CREDIT_TRUE</code></li><li><code>system:HAS_CREDIT_FALSE</code></li><li><code>system:MODE_STARTED</code></li><li><code>system:MODE_ENDED</code></li><li><code>system:BOOT_COMPLETED</code></li><li><code>system:ENABLE_GRANTED</code></li><li><code>system:ENABLE_REVOKED</code></li><li><code>system:IDLE_ENTERED</code></li><li><code>system:IDLE_EXITED</code></li><li><code>system:BRIDGE_CONNECTED</code></li><li><code>system:BRIDGE_DISCONNECTED</code></li><li><code>system:CONFIG_SYNCED</code></li><li><code>system:FAULT_RAISED</code></li><li><code>system:FAULT_CLEARED</code></li><li><code>system:WATCHDOG_TRIGGERED</code></li></ul><h3>Hardware handlers</h3><ul><li><code>hardware:button:CLICKED</code></li><li><code>hardware:button:DOUBLE_CLICKED</code></li><li><code>hardware:button:HELD</code></li><li><code>hardware:button:PRESSED</code></li><li><code>hardware:button:RELEASED</code></li><li><code>hardware:button:REPEAT_WHILE_HELD</code></li><li><code>hardware:switch:CLOSED</code></li><li><code>hardware:switch:OPENED</code></li><li><code>hardware:switch:CHANGED</code></li><li><code>hardware:switch:ACTIVE_FOR_MS</code></li><li><code>hardware:switch:INACTIVE_FOR_MS</code></li><li><code>hardware:gyro:TILT_NUDGE</code></li><li><code>hardware:gyro:TILT_WARNING</code></li><li><code>hardware:gyro:TILT_TRIGGERED</code></li><li><code>hardware:gyro:LIFTED</code></li><li><code>hardware:gyro:DROPPED</code></li><li><code>hardware:nfc:NFC_SCANNED</code></li><li><code>hardware:nfc:NFC_MATCHED</code></li></ul><h3>Custom handlers</h3><ul><li><code>custom</code></li></ul><h2>Current Behavior</h2><h3>API path (<code>/api/events/fire</code>)</h3><ol><li>Event is validated against rules registry + source mapping.</li><li>Event is emitted to Pi event bus (<code>get_bus().emit(...)</code>).</li><li>Event Manager dispatch runs for the same event context (<code>origin=\\&quot;api\\&quot;</code>).</li></ol><h3>Bridge RX path (<code>EVT</code>/<code>EVENT</code>)</h3><ol><li>Bridge receives framed message from ESP.</li><li>Message is emitted to Pi event bus as before.</li><li>Event Manager dispatch runs for the same event context (<code>origin=\\&quot;bridge\\&quot;</code>).</li></ol><h2>Logging Behavior</h2><ul><li>Event manager dispatch trace is bridge-verbose only:</li><li>appears when <code>LOG_LEVEL=VERBOSE</code></li><li>format: <code>event-mgr dispatch name=... source=... origin=... routes=... handlers=...</code></li><li>Existing event flood visibility rules still apply:</li><li><code>DEBUG</code>: bridge traffic details, but event flood remains suppressed</li><li><code>VERBOSE</code>: full event traffic + event manager trace</li></ul><h2>Coverage / Verification</h2><p>Coverage endpoint:</p><ul><li><code>GET /api/events/coverage</code></li></ul><p>Response reports:</p><ul><li><code>expected_count</code></li><li><code>registered_count</code></li><li><code>missing_count</code></li><li><code>missing</code></li><li><code>complete</code></li></ul><p>Current expected state after this implementation:</p><ul><li><code>expected_count = 40</code></li><li><code>registered_count = 40</code></li><li><code>missing_count = 0</code></li><li><code>complete = true</code></li></ul><h2>What Is Implemented vs Stubbed</h2><p>Implemented now:</p><ul><li>Single Event Manager abstraction and dispatch interface</li><li>Registry-driven route registration</li><li>Source-&gt;deviceClass resolution via <code>instance/hardware/mapping.json</code></li><li>Ingress wiring for both API and Bridge RX paths</li><li>Coverage endpoint for completeness checks</li></ul><p>Still stubbed (next phase):</p><ul><li>Real gameplay/scoring/state mutation handlers on Pi</li><li>Rule-action execution logic at handler level</li><li>Per-handler metrics and timing instrumentation</li></ul><h2>Compatibility Notes</h2><ul><li>No protocol change (frames-only transport unchanged)</li><li>No Playfield contract change (<code>/api/events/fire</code> and <code>/api/events/stream</code> unchanged)</li><li>No rules save/sync contract change</li></ul>","plain":"Pi Event Manager: Handlers and Current State This document describes the current Pi-side Event Manager implementation, including all registered handler routes and current behavior. Scope Pi Event Manager is implemented in: src/pinballctl/events/manager.py It is currently wired at two ingress points: API-origin events: POST /api/events/fire implementation: src/pinballctl/app/modules/events/api.py Bridge-origin events from ESP EVT/EVENT : implementation: src/pinballctl/bridge/daemon.py Handler Model Event Manager uses route keys and registered handlers: system: hardware: : custom event: dynamic route key all global route key Current registered default handlers are explicit no-op stubs NoopHandler for all rules-defined system and hardware route keys plus custom. This gives a stable, centralized interface now, with business logic to be added incrementally later. Current Registered Handlers The manager currently auto-registers these route keys from rules registry: System handlers system:GAMESTARTED system:GAMEENDED system:BALLSTARTED system:BALLENDED system:PLAYERADDED system:CREDITSCHANGED system:HASCREDITTRUE system:HASCREDITFALSE system:MODESTARTED system:MODEENDED system:BOOTCOMPLETED system:ENABLEGRANTED system:ENABLEREVOKED system:IDLEENTERED system:IDLEEXITED system:BRIDGECONNECTED system:BRIDGEDISCONNECTED system:CONFIGSYNCED system:FAULTRAISED system:FAULTCLEARED system:WATCHDOGTRIGGERED Hardware handlers hardware:button:CLICKED hardware:button:DOUBLECLICKED hardware:button:HELD hardware:button:PRESSED hardware:button:RELEASED hardware:button:REPEATWHILEHELD hardware:switch:CLOSED hardware:switch:OPENED hardware:switch:CHANGED hardware:switch:ACTIVEFORMS hardware:switch:INACTIVEFORMS hardware:gyro:TILTNUDGE hardware:gyro:TILTWARNING hardware:gyro:TILTTRIGGERED hardware:gyro:LIFTED hardware:gyro:DROPPED hardware:nfc:NFCSCANNED hardware:nfc:NFCMATCHED Custom handlers custom Current Behavior API path /api/events/fire Event is validated against rules registry + source mapping. Event is emitted to Pi event bus getbus .emit ... . Event Manager dispatch runs for the same event context origin=\\\"api\\\" . Bridge RX path EVT/EVENT Bridge receives framed message from ESP. Message is emitted to Pi event bus as before. Event Manager dispatch runs for the same event context origin=\\\"bridge\\\" . Logging Behavior Event manager dispatch trace is bridge-verbose only: appears when LOGLEVEL=VERBOSE format: event-mgr dispatch name=... source=... origin=... routes=... handlers=... Existing event flood visibility rules still apply: DEBUG: bridge traffic details, but event flood remains suppressed VERBOSE: full event traffic + event manager trace Coverage / Verification Coverage endpoint: GET /api/events/coverage Response reports: expectedcount registeredcount missingcount missing complete Current expected state after this implementation: expectedcount = 40 registeredcount = 40 missingcount = 0 complete = true What Is Implemented vs Stubbed Implemented now: Single Event Manager abstraction and dispatch interface Registry-driven route registration Source->deviceClass resolution via instance/hardware/mapping.json Ingress wiring for both API and Bridge RX paths Coverage endpoint for completeness checks Still stubbed next phase : Real gameplay/scoring/state mutation handlers on Pi Rule-action execution logic at handler level Per-handler metrics and timing instrumentation Compatibility Notes No protocol change frames-only transport unchanged No Playfield contract change /api/events/fire and /api/events/stream unchanged No rules save/sync contract change","excerpt":"Pi Event Manager: Handlers and Current State This document describes the current Pi-side Event Manager implementation, including all registered handler routes and current behavior. Scope Pi Event Manager is implemented..."},{"slug":"2-technical-notes/from-app-docs/PACKAGING","path":"2-technical-notes/from-app-docs/PACKAGING.md","title":"In the project root:","order":10000,"html":"<h1>1) In the project root:</h1><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install build</code></pre><h1>2) Build the package (creates wheel + sdist in ./dist/)</h1><pre><code>python -m build</code></pre><h1>You should now have something like:</h1><p>dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz</p><p>Create a new GITHUB release with</p><p>gh release create v0.1.0 dist/*</p><h1>To upgrade using a release</h1><p>pip install --upgrade https://github.com/pinballctl/pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl pinballctl service restart all</p>","plain":"1 In the project root: 2 Build the package creates wheel + sdist in ./dist/ You should now have something like: dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz Create a new GITHUB release with gh release create v0.1.0 dist/ To upgrade using a release pip install --upgrade https://github.com/pinballctl/pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl pinballctl service restart all","excerpt":"1 In the project root: 2 Build the package creates wheel + sdist in ./dist/ You should now have something like: dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz Create a new GITHUB release with gh..."},{"slug":"2-technical-notes/from-app-docs/RUNNING","path":"2-technical-notes/from-app-docs/RUNNING.md","title":"Running pinballctl","order":10000,"html":"<h1>Running pinballctl</h1><p>This guide covers the supported ways to run the project:</p><ul><li>Local development (live/editable)</li><li>Local install from a wheel (no source checkout)</li><li>Install from a GitHub Release (3rd party style)</li><li>(Future) Install from PyPI</li><li>Managing services (systemd)</li><li>Upgrading &amp; uninstalling</li><li>Troubleshooting</li></ul><p>---</p><h2>Terminology</h2><ul><li><strong>venv</strong>: A per-project, isolated Python environment (recommended for everything).</li><li><strong>Editable install</strong> (<code>pip install -e .</code>): Runs your code “live” from the source folder—perfect for development.</li><li><strong>Wheel</strong> (<code>.whl</code>): A built package you can install without having the source repository.</li></ul><p>---</p><h2>1) Local Development (editable, “live”)</h2><p>Best while you’re coding and testing changes.</p><pre><code># From the project root (where pyproject.toml lives)\npython -m venv .venv\nsource .venv/bin/activate\npip install -e .\n\n# Run the app/bridge directly\npinballctl --version\npinballctl web --host 0.0.0.0 --port 5000\npinballctl bridge --port /dev/ttyUSB0 --baud 115200</code></pre><p><strong>What this does</strong></p><ul><li>Installs an import link into <code>.venv</code> so edits to <code>src/pinballctl/...</code> take effect immediately—no rebuild needed.</li><li>Installs the <code>pinballctl</code> CLI into <code>.venv/bin</code>.</li></ul><p><strong>When to use</strong></p><ul><li>Daily development, quick iterations, working on features/bugfixes.</li></ul><p>---</p><h2>1b) Local Development + Services</h2><p>You can also run your <strong>dev build</strong> under systemd:</p><pre><code># With the venv activated (created as above)\npinballctl service install                # renders venv-aware units, installs, enables, starts\npinballctl status                         # shows web/bridge states, Wi-Fi SSID/IP, ESP ports</code></pre><ul><li>The installer prefers your current <code>.venv/bin</code> so services use the dev environment.</li><li>When you change code, just restart services:</li></ul><pre><code>  pinballctl service restart all</code></pre><p><strong>Great for</strong></p><ul><li>Testing real boot/lifecycle behavior with systemd, logs, restarts, etc.</li></ul><p>---</p><h2>2) Local Install from a Wheel (no source on target)</h2><p>Package once, install anywhere—like a user would.</p><pre><code># On your dev machine (build once)\npython -m venv .venv\nsource .venv/bin/activate\npip install build\npython -m build\n# -&gt; dist/pinballctl-&lt;ver&gt;-py3-none-any.whl\n\n# On the target (e.g., Pi)\npython -m venv .venv\nsource .venv/bin/activate\npip install /path/to/dist/pinballctl-&lt;ver&gt;-py3-none-any.whl\n\n# Optional services\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>You want a clean installation without the source tree on the target machine.</li></ul><p>---</p><h2>3) Install from a GitHub Release (3rd party style)</h2><p>After you publish a Release with attached artifacts:</p><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install https://github.com/&lt;you&gt;/pinballctl/releases/download/vX.Y.Z/pinballctl-X.Y.Z-py3-none-any.whl\n\n# Optional services\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>Treat GitHub Releases as your “package registry.”</li><li>Ideal for testers or other machines where you don’t want to build locally.</li></ul><p>---</p><h2>4) (Future) Install from PyPI</h2><p>Once you publish:</p><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install pinballctl\n\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>Public distribution with the simplest installation UX.</li></ul><p>---</p><h2>Service Management (systemd)</h2><p>All via the CLI:</p><pre><code># Install/uninstall units (venv-aware)\npinballctl service install\npinballctl service uninstall\n\n# Control services\npinballctl service start|stop|restart web\npinballctl service start|stop|restart bridge\npinballctl service restart all\n\n# Status (services, SSID/IP, ESP ports)\npinballctl status</code></pre><p><strong>What service install does</strong></p><ul><li>Detects your <code>.venv/bin</code> and uses it for <code>ExecStart</code>.</li><li>Creates a default <code>gunicorn.conf.py</code> in the working directory if missing.</li><li>Copies rendered units to <code>/etc/systemd/system/</code>, runs daemon-reload, enables, and starts services.</li></ul><p>---</p><h2>Upgrading</h2><p><strong>Editable (dev) install</strong></p><pre><code># You’re running from source. Just edit files.\n# If dependencies changed:\npip install -e .\npinballctl service restart all</code></pre><p><strong>Wheel / Release / PyPI</strong></p><pre><code># Upgrade within the same venv\npip install --upgrade &lt;wheel-or-package&gt;\npinballctl service restart all</code></pre><p>Examples:</p><pre><code>pip install --upgrade pinballctl\n# or from a new release:\npip install --upgrade https://github.com/&lt;you&gt;/pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl</code></pre><p><em>Tip:</em> bump the version in <code>pyproject.toml</code> for each release to avoid cache confusion. To reinstall the same version: <code>pip install --force-reinstall --no-deps &lt;wheel-or-package&gt;</code>.</p><p>---</p><h2>Uninstalling</h2><pre><code># Stop and remove services\npinballctl service uninstall\n\n# Remove the package from the active venv\npip uninstall pinballctl</code></pre><p>---</p><h2>Troubleshooting</h2><p><strong><code>zsh: command not found: pinballctl</code></strong></p><ul><li>You’re not in the venv or it’s not installed.</li><p>Activate and install:</p></ul><pre><code>  source .venv/bin/activate\n  pip install -e .    # or pip install pinballctl / &lt;wheel&gt;</code></pre><p>Or run explicitly: <code>./.venv/bin/pinballctl</code>.</p><p><strong>Services don’t start</strong></p><ul><li>Check status/logs:</li></ul><pre><code>  pinballctl status\n  journalctl -u pinballctl-web -e --no-pager\n  journalctl -u pinballctl-bridge -e --no-pager</code></pre><ul><li>Ensure <code>gunicorn</code> is installed in the same venv used by the services:</li></ul><pre><code>  . .venv/bin/activate &amp;&amp; pip install gunicorn</code></pre><ul><li>Reinstall units to point at the right venv:</li></ul><pre><code>  pinballctl service install</code></pre><p><strong>ESP not detected</strong></p><ul><li><code>pinballctl status</code> lists <code>/dev/ttyUSB<em></code> and <code>/dev/ttyACM</em></code>.</li><p>Check permissions: add your user to the <code>dialout</code> group (Debian/RPi OS):</p></ul><pre><code>  sudo usermod -a -G dialout $USER\n  newgrp dialout</code></pre><p>Then try <code>pinballctl bridge --port /dev/ttyUSB0</code>.</p><p><strong>Network info missing</strong></p><ul><li><code>status</code> uses <code>iwgetid</code>/<code>nmcli</code> and <code>hostname -I</code>. Install tools if needed:</li></ul><pre><code>  sudo apt install wireless-tools network-manager</code></pre><p>---</p><h2>Quick decision table</h2><p>| Goal | Best Method | |------|-------------| | Hack on code &amp; test instantly | <strong>Editable dev</strong> (<code>pip install -e .</code>) | | Deploy to a Pi with no source | <strong>Wheel install</strong> (local file or GitHub Release) | | Public distribution | <strong>PyPI</strong> | | Run as services | <code>pinballctl service install</code> + <code>pinballctl service start all</code> | | Check everything | <code>pinballctl status</code> |</p>","plain":"Running pinballctl This guide covers the supported ways to run the project: Local development live/editable Local install from a wheel no source checkout Install from a GitHub Release 3rd party style Future Install from PyPI Managing services systemd Upgrading & uninstalling Troubleshooting --- Terminology venv: A per-project, isolated Python environment recommended for everything . Editable install pip install -e . : Runs your code “live” from the source folder—perfect for development. Wheel .whl : A built package you can install without having the source repository. --- 1 Local Development editable, “live” Best while you’re coding and testing changes. What this does Installs an import link into .venv so edits to src/pinballctl/... take effect immediately—no rebuild needed. Installs the pinballctl CLI into .venv/bin. When to use Daily development, quick iterations, working on features/bugfixes. --- 1b Local Development + Services You can also run your dev build under systemd: The installer prefers your current .venv/bin so services use the dev environment. When you change code, just restart services: Great for Testing real boot/lifecycle behavior with systemd, logs, restarts, etc. --- 2 Local Install from a Wheel no source on target Package once, install anywhere—like a user would. When to use You want a clean installation without the source tree on the target machine. --- 3 Install from a GitHub Release 3rd party style After you publish a Release with attached artifacts: When to use Treat GitHub Releases as your “package registry.” Ideal for testers or other machines where you don’t want to build locally. --- 4 Future Install from PyPI Once you publish: When to use Public distribution with the simplest installation UX. --- Service Management systemd All via the CLI: What service install does Detects your .venv/bin and uses it for ExecStart. Creates a default gunicorn.conf.py in the working directory if missing. Copies rendered units to /etc/systemd/system/, runs daemon-reload, enables, and starts services. --- Upgrading Editable dev install Wheel / Release / PyPI Examples: Tip: bump the version in pyproject.toml for each release to avoid cache confusion. To reinstall the same version: pip install --force-reinstall --no-deps . --- Uninstalling --- Troubleshooting zsh: command not found: pinballctl You’re not in the venv or it’s not installed. Activate and install: Or run explicitly: ./.venv/bin/pinballctl. Services don’t start Check status/logs: Ensure gunicorn is installed in the same venv used by the services: Reinstall units to point at the right venv: ESP not detected pinballctl status lists /dev/ttyUSB and /dev/ttyACM. Check permissions: add your user to the dialout group Debian/RPi OS : Then try pinballctl bridge --port /dev/ttyUSB0. Network info missing status uses iwgetid/nmcli and hostname -I. Install tools if needed: --- Quick decision table | Goal | Best Method | |------|-------------| | Hack on code & test instantly | Editable dev pip install -e . | | Deploy to a Pi with no source | Wheel install local file or GitHub Release | | Public distribution | PyPI | | Run as services | pinballctl service install + pinballctl service start all | | Check everything | pinballctl status |","excerpt":"Running pinballctl This guide covers the supported ways to run the project: Local development live/editable Local install from a wheel no source checkout Install from a GitHub Release 3rd party style Future Install from..."},{"slug":"2-technical-notes/from-app-docs/SYSTEM","path":"2-technical-notes/from-app-docs/SYSTEM.md","title":"SYSTEM","order":10000,"html":"<h1>SYSTEM</h1><h2>1. High-level architecture (ESP vs Pi responsibilities)</h2><ul><li>ESP32-S3 firmware streams hardware pin data over serial and emits periodic <code>PING</code> frames.</li><li>ESP32-S3 firmware responds to commands: <code>HELLO</code>, <code>GET_INFO</code>, <code>GET_HW</code>, and <code>SYNC_TIME</code>.</li><li>Raspberry Pi runs a bridge daemon that reads framed serial messages, logs them, and writes hardware snapshots to <code>src/instance/hardware/discovered.json</code>.</li><li>Raspberry Pi exposes a Flask-based UI and API; hardware UI reads <code>/api/hardware/pins</code> and <code>/api/hardware/reload</code>.</li><li>Bridge state (port, firmware, chip, time sync) is persisted in <code>src/instance/bridge/bridge_state.json</code>.</li></ul><h2>2. Communication model (protocol shape, framing, direction)</h2><ul><li>ESP -&gt; Pi uses length-prefixed frames: 4-byte big-endian length header + JSON payload (<code>writeFramed</code>).</li><li>Pi -&gt; ESP uses the same framed transport: 4-byte big-endian length + UTF-8 JSON payload.</li><li>Messages are JSON objects with a <code>t</code> field for event type (e.g., <code>INFO</code>, <code>PING</code>, <code>HW_BEGIN</code>, <code>HW_PIN</code>, <code>HW_END</code>, <code>TIME</code>).</li><li>HW discovery is streamed with <code>HW_STATUS</code> + <code>HW_BEGIN</code> + multiple <code>HW_PIN</code> + <code>HW_END</code>.</li><li>Firmware emits <code>HW_PROBE</code> before probing a GPIO when probing is enabled.</li><li>Bridge processes frames with <code>_read_frame</code> and decodes JSON.</li><li>Bridge queues outbound commands via unix sockets (<code>bridge_cmd.sock</code> primary, <code>bridge_rpc.sock</code> for request/reply) with optional file fallback at <code>src/instance/bridge/bridge_commands.json</code>.</li></ul><h2>3. Hardware interaction model</h2><ul><li>ESP firmware maintains a static <code>PIN_TABLE</code> describing pins and metadata (<code>reported</code>, <code>notes</code>, <code>safe</code>).</li><li>Pins with <code>safe=false</code> are never probed.</li><li>Probing (when enabled) is input-only: <code>pinMode(INPUT)</code> + <code>digitalRead()</code>.</li><li>GPIO probing is gated by <code>ALLOW_GPIO_PROBE</code> in firmware.</li><li>Hardware discovery is non-blocking and paced (<code>serviceHardwareStream</code>).</li><li>Pin state is included in <code>HW_PIN</code> payload only when probing occurs.</li></ul><h2>4. Known constraints explicitly visible in code</h2><ul><li>Hardware stream timeout cap: <code>HW_STREAM_TIMEOUT_MS = 8000</code>.</li><li>Serial framing: max frame size limited by <code>TX_FRAME_MAX</code> (512 bytes in firmware).</li><li>TX queue depth: <code>TX_QUEUE_MAX = 4</code> frames in firmware.</li><li>Bridge read resync: resets input buffer when header/body timeouts occur.</li><li>Bridge logs only raw RX lines at DEBUG level (no parsed JSON).</li><li>Hardware snapshot is stored at <code>src/instance/hardware/discovered.json</code>.</li><li>Hardware UI uses <code>reported</code> and <code>notes</code> fields to display pin notes.</li></ul><h2>5. Areas of uncertainty / risk (UNKNOWN)</h2><ul><li>UNKNOWN: Which GPIOs are truly safe to probe for a specific ESP32-S3-DevKitC-1 module beyond the <code>PIN_TABLE</code> defaults.</li><li>UNKNOWN: Whether USB-CDC or other serial transport variations affect framing reliability.</li><li>UNKNOWN: Any external expansion board detection mechanisms beyond GPIO probing (not visible in code).</li></ul><h2>6. Modules and UI functionality</h2><ul><li>Dashboard UI: Wi‑Fi status (interface/connected/SSID/IP/signal), bridge status (status/via/PID), uptime (since/duration/seconds), ESP32 info (firmware/chip/time/connected/time sync), sync states, dependencies list.</li><li>Logs UI: source tabs, line count, keyword filter, file selection, refresh/clear/purge, tail toggle, log viewport/JSON inspect.</li><li>Hardware UI: reload pins, save mapping, table of UID/board/type/notes/channel/state/friendly/function/purpose, mapping safety constraints.</li><li>ESPLink UI: device selection, status/firmware display, refresh/reboot/sync time, bridge start/stop/restart, local firmware list, upload console.</li><li>Firmware UI: list available versions with source selection (default/custom URL), load remote, remove all local versions.</li><li>Settings UI: tabbed settings and import/export workflows (project/admin/runtime options, export bundle, import bundle).</li><li>Wi‑Fi UI: current status (SSID/IP/status/connected), update settings (SSID/password), save.</li><li>Playfield UI: tabbed stage/options workflows, layout table, size/ratio options, auto layout/clear/save layout, component list and component settings.</li><li>Rules UI: add/save/sync rules, filters, rules table, editor tabs for metadata/triggers/conditions/actions/preview.</li><li>Scoring UI: tabbed base points/scoring rules/combos workflows for scoring authoring and save.</li><li>Lighting UI: tabbed stage/fixtures workflows, scene management, preview/playback controls, fixture editing and save/sync.</li><li>Media UI: tabbed stage/library/displays/runtime workflows, scene and overlay authoring, playback controls, kiosk/window launch, runtime session controls.</li><li>Audio UI: tabbed library/cues/outputs/usage-map workflows, cue routing, runtime playback visibility and control.</li><li>Service Log UI: maintenance entry list/detail workflow, filtering, create/edit service records.</li><li>Manual UI: built-in documentation browser with search, tree, bookmarks, and in-page media viewer.</li><li>Events module: backend event/routing support module (no primary end-user page).</li></ul><h2>7. Pin mapping goals and UX principles (user-provided)</h2><ul><li>Target users may be non-technical; UI should avoid GPIO jargon where possible.</li><li>Mapping should guide users from unknown hardware to identified device via simple choices.</li><li>Mapping must be safe: ESP firmware must never drive/probe unsafe pins; mapping cannot override safe=false.</li><li>UI should distinguish discovered pins, mapped devices, and active configuration.</li></ul><h2>8. Pin mapping data model (proposed minimal shape; user-provided)</h2><ul><li>A pin is identified by stable <code>uid</code> from firmware (preferred key).</li><li>Mapping is stored on the Pi (not in firmware) and can be applied/config-pushed to ESP later.</li><li>Each mapping record contains:</li><li><code>uid</code>: string (from HW_PIN).</li><li><code>gpio</code>: number|null (optional convenience; do not rely on it for uniqueness).</li><li><code>device_type</code>: enum (e.g., push_button, led_strip, coil, i2c_device, switch_matrix).</li><li><code>label</code>: human-friendly name.</li><li><code>config</code>: object keyed by type.</li><li><code>enabled</code>: bool.</li><li><code>created_at</code>, <code>updated_at</code>: timestamps (optional).</li><li>Example mapping JSON: UNKNOWN (not provided).</li></ul><h2>9. Pin mapping invariants (non-negotiable rules; user-provided)</h2><ul><li>Mapping must never assign a device to a pin where <code>safe=false</code>.</li><li>A <code>uid</code> can map to at most one device at a time (no duplicates).</li><li>UI must prevent conflicting assignments (e.g., two devices on the same <code>uid</code>).</li><li>Reload pins updates discovery state but must not destroy mappings:</li><li>If a mapped <code>uid</code> disappears, mapping is kept but flagged &quot;missing&quot;.</li><li>If a discovered <code>uid</code> is new, it appears as &quot;unmapped&quot;.</li><li>Mapping changes should be atomic (save either succeeds fully or not at all).</li><li>UI should support an Apply/Deploy step separately from Edit mapping.</li></ul>","plain":"SYSTEM High-level architecture ESP vs Pi responsibilities ESP32-S3 firmware streams hardware pin data over serial and emits periodic PING frames. ESP32-S3 firmware responds to commands: HELLO, GETINFO, GETHW, and SYNCTIME. Raspberry Pi runs a bridge daemon that reads framed serial messages, logs them, and writes hardware snapshots to src/instance/hardware/discovered.json. Raspberry Pi exposes a Flask-based UI and API; hardware UI reads /api/hardware/pins and /api/hardware/reload. Bridge state port, firmware, chip, time sync is persisted in src/instance/bridge/bridgestate.json. Communication model protocol shape, framing, direction ESP -> Pi uses length-prefixed frames: 4-byte big-endian length header + JSON payload writeFramed . Pi -> ESP uses the same framed transport: 4-byte big-endian length + UTF-8 JSON payload. Messages are JSON objects with a t field for event type e.g., INFO, PING, HWBEGIN, HWPIN, HWEND, TIME . HW discovery is streamed with HWSTATUS + HWBEGIN + multiple HWPIN + HWEND. Firmware emits HWPROBE before probing a GPIO when probing is enabled. Bridge processes frames with readframe and decodes JSON. Bridge queues outbound commands via unix sockets bridgecmd.sock primary, bridgerpc.sock for request/reply with optional file fallback at src/instance/bridge/bridgecommands.json. Hardware interaction model ESP firmware maintains a static PINTABLE describing pins and metadata reported, notes, safe . Pins with safe=false are never probed. Probing when enabled is input-only: pinMode INPUT + digitalRead . GPIO probing is gated by ALLOWGPIOPROBE in firmware. Hardware discovery is non-blocking and paced serviceHardwareStream . Pin state is included in HWPIN payload only when probing occurs. Known constraints explicitly visible in code Hardware stream timeout cap: HWSTREAMTIMEOUTMS = 8000. Serial framing: max frame size limited by TXFRAMEMAX 512 bytes in firmware . TX queue depth: TXQUEUEMAX = 4 frames in firmware. Bridge read resync: resets input buffer when header/body timeouts occur. Bridge logs only raw RX lines at DEBUG level no parsed JSON . Hardware snapshot is stored at src/instance/hardware/discovered.json. Hardware UI uses reported and notes fields to display pin notes. Areas of uncertainty / risk UNKNOWN UNKNOWN: Which GPIOs are truly safe to probe for a specific ESP32-S3-DevKitC-1 module beyond the PINTABLE defaults. UNKNOWN: Whether USB-CDC or other serial transport variations affect framing reliability. UNKNOWN: Any external expansion board detection mechanisms beyond GPIO probing not visible in code . Modules and UI functionality Dashboard UI: Wi‑Fi status interface/connected/SSID/IP/signal , bridge status status/via/PID , uptime since/duration/seconds , ESP32 info firmware/chip/time/connected/time sync , sync states, dependencies list. Logs UI: source tabs, line count, keyword filter, file selection, refresh/clear/purge, tail toggle, log viewport/JSON inspect. Hardware UI: reload pins, save mapping, table of UID/board/type/notes/channel/state/friendly/function/purpose, mapping safety constraints. ESPLink UI: device selection, status/firmware display, refresh/reboot/sync time, bridge start/stop/restart, local firmware list, upload console. Firmware UI: list available versions with source selection default/custom URL , load remote, remove all local versions. Settings UI: tabbed settings and import/export workflows project/admin/runtime options, export bundle, import bundle . Wi‑Fi UI: current status SSID/IP/status/connected , update settings SSID/password , save. Playfield UI: tabbed stage/options workflows, layout table, size/ratio options, auto layout/clear/save layout, component list and component settings. Rules UI: add/save/sync rules, filters, rules table, editor tabs for metadata/triggers/conditions/actions/preview. Scoring UI: tabbed base points/scoring rules/combos workflows for scoring authoring and save. Lighting UI: tabbed stage/fixtures workflows, scene management, preview/playback controls, fixture editing and save/sync. Media UI: tabbed stage/library/displays/runtime workflows, scene and overlay authoring, playback controls, kiosk/window launch, runtime session controls. Audio UI: tabbed library/cues/outputs/usage-map workflows, cue routing, runtime playback visibility and control. Service Log UI: maintenance entry list/detail workflow, filtering, create/edit service records. Manual UI: built-in documentation browser with search, tree, bookmarks, and in-page media viewer. Events module: backend event/routing support module no primary end-user page . Pin mapping goals and UX principles user-provided Target users may be non-technical; UI should avoid GPIO jargon where possible. Mapping should guide users from unknown hardware to identified device via simple choices. Mapping must be safe: ESP firmware must never drive/probe unsafe pins; mapping cannot override safe=false. UI should distinguish discovered pins, mapped devices, and active configuration. Pin mapping data model proposed minimal shape; user-provided A pin is identified by stable uid from firmware preferred key . Mapping is stored on the Pi not in firmware and can be applied/config-pushed to ESP later. Each mapping record contains: uid: string from HWPIN . gpio: number|null optional convenience; do not rely on it for uniqueness . devicetype: enum e.g., pushbutton, ledstrip, coil, i2cdevice, switchmatrix . label: human-friendly name. config: object keyed by type. enabled: bool. createdat, updatedat: timestamps optional . Example mapping JSON: UNKNOWN not provided . Pin mapping invariants non-negotiable rules; user-provided Mapping must never assign a device to a pin where safe=false. A uid can map to at most one device at a time no duplicates . UI must prevent conflicting assignments e.g., two devices on the same uid . Reload pins updates discovery state but must not destroy mappings: If a mapped uid disappears, mapping is kept but flagged \"missing\". If a discovered uid is new, it appears as \"unmapped\". Mapping changes should be atomic save either succeeds fully or not at all . UI should support an Apply/Deploy step separately from Edit mapping.","excerpt":"SYSTEM High-level architecture ESP vs Pi responsibilities ESP32-S3 firmware streams hardware pin data over serial and emits periodic PING frames. ESP32-S3 firmware responds to commands: HELLO, GETINFO, GETHW, and..."},{"slug":"2-technical-notes/modules/README","path":"2-technical-notes/modules/README.md","title":"Technical Module Reference","order":10000,"html":"<h1>Technical Module Reference</h1><p>This section contains the technical module pages copied from the original Application/Modules set.</p><h2>Pages</h2><ul><li><a href=\"#doc=2-technical-notes/modules/dashboard\">Dashboard</a></li><li><a href=\"#doc=2-technical-notes/modules/rules\">Rules</a></li><li><a href=\"layout-Playfield.md\">Layout (Playfield)</a></li><li><a href=\"#doc=2-technical-notes/modules/hardware\">Hardware</a></li><li><a href=\"#doc=2-technical-notes/modules/firmware\">Firmware</a></li><li><a href=\"#doc=2-technical-notes/modules/esplink\">ESPLink</a></li><li><a href=\"#doc=2-technical-notes/modules/logs\">Logs</a></li><li><a href=\"#doc=2-technical-notes/modules/service-log\">Service Log</a></li><li><a href=\"#doc=2-technical-notes/modules/wifi\">Wi-Fi</a></li><li><a href=\"#doc=2-technical-notes/modules/settings\">Settings</a></li><li><a href=\"#doc=2-technical-notes/modules/events-api\">Events API</a></li></ul>","plain":"Technical Module Reference This section contains the technical module pages copied from the original Application/Modules set. Pages Dashboard Rules Layout Playfield Hardware Firmware ESPLink Logs Service Log Wi-Fi Settings Events API","excerpt":"Technical Module Reference This section contains the technical module pages copied from the original Application/Modules set. Pages Dashboard Rules Layout Playfield Hardware Firmware ESPLink Logs Service Log Wi-Fi..."},{"slug":"2-technical-notes/modules/dashboard","path":"2-technical-notes/modules/dashboard.md","title":"Dashboard Module","order":10000,"html":"<h1>Dashboard Module</h1><h2>Purpose</h2><p>Primary at-a-glance status page for machine and system state.</p><h2>Functionality</h2><ul><li>Shows high-level platform status and key runtime signals.</li><li>Serves as the default landing page.</li><li>Provides quick visual confirmation before deeper operations.</li></ul><h2>Typical Use</h2><ul><li>First page operators open after startup.</li><li>Quick pre-check before configuration/deployment changes.</li></ul>","plain":"Dashboard Module Purpose Primary at-a-glance status page for machine and system state. Functionality Shows high-level platform status and key runtime signals. Serves as the default landing page. Provides quick visual confirmation before deeper operations. Typical Use First page operators open after startup. Quick pre-check before configuration/deployment changes.","excerpt":"Dashboard Module Purpose Primary at-a-glance status page for machine and system state. Functionality Shows high-level platform status and key runtime signals. Serves as the default landing page. Provides quick visual..."},{"slug":"2-technical-notes/modules/esplink","path":"2-technical-notes/modules/esplink.md","title":"ESPLink Module","order":10000,"html":"<h1>ESPLink Module</h1><h2>Purpose</h2><p>Bridge and ESP device operations panel for connectivity, filesystem, version management, and upload flows.</p><h2>Functionality</h2><ul><li>Detects devices and bridge status.</li><li>Starts/stops/restarts bridge service actions.</li><li>Queries device info/status and FS status/listings.</li><li>Uploads/syncs assets to device targets.</li><li>Supports reboot/time-sync and version downloads.</li></ul><h2>Key Endpoints (subset)</h2><ul><li><code>GET /api/esplink/devices</code></li><li><code>GET /api/esplink/bridge/status</code></li><li><code>POST /api/esplink/bridge/start|stop|restart</code></li><li><code>POST /api/esplink/devices/&lt;id&gt;/fs-status</code></li><li><code>POST /api/esplink/devices/&lt;id&gt;/upload</code></li></ul>","plain":"ESPLink Module Purpose Bridge and ESP device operations panel for connectivity, filesystem, version management, and upload flows. Functionality Detects devices and bridge status. Starts/stops/restarts bridge service actions. Queries device info/status and FS status/listings. Uploads/syncs assets to device targets. Supports reboot/time-sync and version downloads. Key Endpoints subset GET /api/esplink/devices GET /api/esplink/bridge/status POST /api/esplink/bridge/start|stop|restart POST /api/esplink/devices/ /fs-status POST /api/esplink/devices/ /upload","excerpt":"ESPLink Module Purpose Bridge and ESP device operations panel for connectivity, filesystem, version management, and upload flows. Functionality Detects devices and bridge status. Starts/stops/restarts bridge service..."},{"slug":"2-technical-notes/modules/events-api","path":"2-technical-notes/modules/events-api.md","title":"Events API Module (Internal)","order":10000,"html":"<h1>Events API Module (Internal)</h1><h2>Purpose</h2><p>Internal event bus API used by modules/services to emit and stream events.</p><h2>Functionality</h2><ul><li>Returns event registry metadata.</li><li>Validates and fires events.</li><li>Streams events over SSE.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/events/registry</code></li><li><code>POST /api/events/fire</code></li><li><code>GET /api/events/stream</code></li></ul><h2>Notes</h2><p>This module is API-first and hidden from top-level menu navigation.</p>","plain":"Events API Module Internal Purpose Internal event bus API used by modules/services to emit and stream events. Functionality Returns event registry metadata. Validates and fires events. Streams events over SSE. Key Endpoints GET /api/events/registry POST /api/events/fire GET /api/events/stream Notes This module is API-first and hidden from top-level menu navigation.","excerpt":"Events API Module Internal Purpose Internal event bus API used by modules/services to emit and stream events. Functionality Returns event registry metadata. Validates and fires events. Streams events over SSE. Key..."},{"slug":"2-technical-notes/modules/firmware","path":"2-technical-notes/modules/firmware.md","title":"Firmware Module","order":10000,"html":"<h1>Firmware Module</h1><h2>Purpose</h2><p>Manages firmware artifacts and update package handling.</p><h2>Functionality</h2><ul><li>Lists local and remote firmware versions.</li><li>Downloads remote firmware assets.</li><li>Deletes single/all local versions.</li><li>Serves firmware download files.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/firmware/versions</code></li><li><code>GET /api/firmware/versions/remote</code></li><li><code>POST /api/firmware/delete</code></li><li><code>POST /api/firmware/delete/all</code></li><li><code>GET /api/firmware/download/&lt;filename&gt;</code></li></ul>","plain":"Firmware Module Purpose Manages firmware artifacts and update package handling. Functionality Lists local and remote firmware versions. Downloads remote firmware assets. Deletes single/all local versions. Serves firmware download files. Key Endpoints GET /api/firmware/versions GET /api/firmware/versions/remote POST /api/firmware/delete POST /api/firmware/delete/all GET /api/firmware/download/","excerpt":"Firmware Module Purpose Manages firmware artifacts and update package handling. Functionality Lists local and remote firmware versions. Downloads remote firmware assets. Deletes single/all local versions. Serves..."},{"slug":"2-technical-notes/modules/hardware","path":"2-technical-notes/modules/hardware.md","title":"Hardware Module","order":10000,"html":"<h1>Hardware Module</h1><h2>Purpose</h2><p>Maps discovered hardware/pins to logical functions used by the authoring/runtime stack.</p><h2>Functionality</h2><ul><li>Views board metadata and pin availability.</li><li>Loads/saves hardware mapping data.</li><li>Supports mapping reload and sync workflows.</li><li>Provides sync status feedback.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/hardware/meta</code></li><li><code>GET /api/hardware/pins</code></li><li><code>GET /api/hardware/mapping</code></li><li><code>POST /api/hardware/save</code></li><li><code>POST /api/hardware/sync</code></li><li><code>GET /api/hardware/sync/status</code></li></ul>","plain":"Hardware Module Purpose Maps discovered hardware/pins to logical functions used by the authoring/runtime stack. Functionality Views board metadata and pin availability. Loads/saves hardware mapping data. Supports mapping reload and sync workflows. Provides sync status feedback. Key Endpoints GET /api/hardware/meta GET /api/hardware/pins GET /api/hardware/mapping POST /api/hardware/save POST /api/hardware/sync GET /api/hardware/sync/status","excerpt":"Hardware Module Purpose Maps discovered hardware/pins to logical functions used by the authoring/runtime stack. Functionality Views board metadata and pin availability. Loads/saves hardware mapping data. Supports..."},{"slug":"2-technical-notes/modules/logs","path":"2-technical-notes/modules/logs.md","title":"Logs Module","order":10000,"html":"<h1>Logs Module</h1><h2>Purpose</h2><p>Live and historical log inspection for troubleshooting.</p><h2>Functionality</h2><ul><li>Streams/reads log chunks.</li><li>Supports log purge operations.</li><li>UI-oriented tooling for diagnostics.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/logs/chunk</code></li><li><code>POST /api/logs/purge</code></li></ul>","plain":"Logs Module Purpose Live and historical log inspection for troubleshooting. Functionality Streams/reads log chunks. Supports log purge operations. UI-oriented tooling for diagnostics. Key Endpoints GET /api/logs/chunk POST /api/logs/purge","excerpt":"Logs Module Purpose Live and historical log inspection for troubleshooting. Functionality Streams/reads log chunks. Supports log purge operations. UI-oriented tooling for diagnostics. Key Endpoints GET /api/logs/chunk..."},{"slug":"2-technical-notes/modules/playfield","path":"2-technical-notes/modules/playfield.md","title":"Layout (Playfield) Module","order":10000,"html":"<h1>Layout (Playfield) Module</h1><h2>Purpose</h2><p>Visual playfield/layout editor for component placement and key/event mapping.</p><h2>Functionality</h2><ul><li>Drag/drop and resize-style element positioning.</li><li>Component selection and per-component settings.</li><li>Key binding capture and mapped-event linkage.</li><li>Save/load Playfield state and hardware component overlays.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/playfield/state</code></li><li><code>POST /api/playfield/state</code></li><li><code>GET /api/playfield/hardware</code></li></ul>","plain":"Layout Playfield Module Purpose Visual playfield/layout editor for component placement and key/event mapping. Functionality Drag/drop and resize-style element positioning. Component selection and per-component settings. Key binding capture and mapped-event linkage. Save/load Playfield state and hardware component overlays. Key Endpoints GET /api/playfield/state POST /api/playfield/state GET /api/playfield/hardware","excerpt":"Layout Playfield Module Purpose Visual playfield/layout editor for component placement and key/event mapping. Functionality Drag/drop and resize-style element positioning. Component selection and per-component settings...."},{"slug":"2-technical-notes/modules/rules","path":"2-technical-notes/modules/rules.md","title":"Rules Module","order":10000,"html":"<h1>Rules Module</h1><h2>Purpose</h2><p>Authoring surface for gameplay/event rules that drive machine behavior.</p><h2>Functionality</h2><ul><li>Loads and edits rulesets.</li><li>Saves rules to persisted JSON.</li><li>Integrates with bridge command flow for ESP updates.</li><li>Exposes sync/status paths for deployment visibility.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/rules/catalog</code></li><li><code>GET /api/rules/list</code></li><li><code>POST /api/rules/save</code></li><li><code>POST /api/rules/sync</code></li><li><code>GET /api/rules/sync/status</code></li></ul>","plain":"Rules Module Purpose Authoring surface for gameplay/event rules that drive machine behavior. Functionality Loads and edits rulesets. Saves rules to persisted JSON. Integrates with bridge command flow for ESP updates. Exposes sync/status paths for deployment visibility. Key Endpoints GET /api/rules/catalog GET /api/rules/list POST /api/rules/save POST /api/rules/sync GET /api/rules/sync/status","excerpt":"Rules Module Purpose Authoring surface for gameplay/event rules that drive machine behavior. Functionality Loads and edits rulesets. Saves rules to persisted JSON. Integrates with bridge command flow for ESP updates...."},{"slug":"2-technical-notes/modules/service-log","path":"2-technical-notes/modules/service-log.md","title":"Service Log Module","order":10000,"html":"<h1>Service Log Module</h1><h2>Purpose</h2><p>Tracks maintenance/service records, notes, and attachments.</p><h2>Functionality</h2><ul><li>Creates, updates, and reads service entries.</li><li>Stores associated attachment records/files.</li><li>Supports audit-style maintenance history.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/service/log</code></li><li><code>POST /api/service/log</code></li><li><code>POST /api/service/log/&lt;entry_id&gt;</code></li><li><code>GET /api/service/log/&lt;entry_id&gt;</code></li><li><code>GET /api/service/attachment/&lt;filename&gt;</code></li></ul>","plain":"Service Log Module Purpose Tracks maintenance/service records, notes, and attachments. Functionality Creates, updates, and reads service entries. Stores associated attachment records/files. Supports audit-style maintenance history. Key Endpoints GET /api/service/log POST /api/service/log POST /api/service/log/ GET /api/service/log/ GET /api/service/attachment/","excerpt":"Service Log Module Purpose Tracks maintenance/service records, notes, and attachments. Functionality Creates, updates, and reads service entries. Stores associated attachment records/files. Supports audit-style..."},{"slug":"2-technical-notes/modules/settings","path":"2-technical-notes/modules/settings.md","title":"Settings Module","order":10000,"html":"<h1>Settings Module</h1><h2>Purpose</h2><p>Project-level settings management and configuration import/export.</p><h2>Functionality</h2><ul><li>Loads current settings payload.</li><li>Saves updated settings.</li><li>Exports settings package.</li><li>Imports settings package.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/settings/data</code></li><li><code>POST /api/settings/save</code></li><li><code>GET /api/settings/export</code></li><li><code>POST /api/settings/import</code></li></ul>","plain":"Settings Module Purpose Project-level settings management and configuration import/export. Functionality Loads current settings payload. Saves updated settings. Exports settings package. Imports settings package. Key Endpoints GET /api/settings/data POST /api/settings/save GET /api/settings/export POST /api/settings/import","excerpt":"Settings Module Purpose Project-level settings management and configuration import/export. Functionality Loads current settings payload. Saves updated settings. Exports settings package. Imports settings package. Key..."},{"slug":"2-technical-notes/modules/wifi","path":"2-technical-notes/modules/wifi.md","title":"Wi Fi Module","order":10000,"html":"<h1>Wi-Fi Module</h1><h2>Purpose</h2><p>Configures and monitors network connectivity for the host environment.</p><h2>Functionality</h2><ul><li>Reads current Wi-Fi/network status.</li><li>Saves Wi-Fi/network configuration.</li><li>Supports onboarding and connectivity checks.</li></ul><h2>Key Endpoints</h2><ul><li><code>GET /api/wifi/status</code></li><li><code>POST /api/wifi/save</code></li></ul>","plain":"Wi-Fi Module Purpose Configures and monitors network connectivity for the host environment. Functionality Reads current Wi-Fi/network status. Saves Wi-Fi/network configuration. Supports onboarding and connectivity checks. Key Endpoints GET /api/wifi/status POST /api/wifi/save","excerpt":"Wi-Fi Module Purpose Configures and monitors network connectivity for the host environment. Functionality Reads current Wi-Fi/network status. Saves Wi-Fi/network configuration. Supports onboarding and connectivity..."},{"slug":"2-technical-notes/specifications/EMULATOR","path":"2-technical-notes/specifications/EMULATOR.md","title":"Emulator","order":10000,"html":"<p>I would like to create a new module, it should be the same structure as our existing ones with a split view.py and api.py.</p><p>This module will emulate the pinball table and the components.</p><p>I would like the content to have 2 columns.</p><p>Column 2 will content multiple headings which can be expanded.</p><ol><li>Options</li><p>This will have a width and height input field. From this we will calculate the ratio. The ratio will be used to size the table in column 1. It should be max 100% width or height and the other edge will use the ratio. We shoudl apply a sharp shadow to the table to make it look nice.</p><li>The next heading will be the functions from the Hardware, e.g. buttons, led etc. When expanding this header it should show the components that we have configured, with the friendly name.</li></ol><p>Column 1 will contain the table. This will just be the rectangle shape and will be responsive to be as large as the window width and height will allow.</p><p>The key feature here is that the components can be dragged and dropped into position on the table (and around the edge of it for buttons etc). This will allow us to emulate and track events. e.g. Drag a button onto the table. We can then click the element to trigger the available events. I am thinking when we get the bridge in place it could also response to events. by lighting the element up. In the case of the LED or RGB strips we can set the matching colour</p><p>It would be nice if in the side bar we could select an element and assign keyboard keys to it. e.g. z = left flipper, m = right flipper</p><p>Basically this is a way to test rules &quot;offline&quot; and would be a really powerful feature for this application.</p><p>Please could you create the full module and make it available as a zip.</p><ol><li>Can the component settings have the available events for this hardware type and be clickable to trigger the event. (The key mapping will trigger the default event) e.g. PRESS / PRESS HOLD / RELEASE etc for a button.</li><li>In the component settings, could we have a size option, small, medium, large. which will resize the components. We don&#x27;t need to get these exact but it would help with the mockup. e.g. LEDS will be small. Pop Bumpers large</li></ol>","plain":"I would like to create a new module, it should be the same structure as our existing ones with a split view.py and api.py. This module will emulate the pinball table and the components. I would like the content to have 2 columns. Column 2 will content multiple headings which can be expanded. Options This will have a width and height input field. From this we will calculate the ratio. The ratio will be used to size the table in column 1. It should be max 100% width or height and the other edge will use the ratio. We shoudl apply a sharp shadow to the table to make it look nice. The next heading will be the functions from the Hardware, e.g. buttons, led etc. When expanding this header it should show the components that we have configured, with the friendly name. Column 1 will contain the table. This will just be the rectangle shape and will be responsive to be as large as the window width and height will allow. The key feature here is that the components can be dragged and dropped into position on the table and around the edge of it for buttons etc . This will allow us to emulate and track events. e.g. Drag a button onto the table. We can then click the element to trigger the available events. I am thinking when we get the bridge in place it could also response to events. by lighting the element up. In the case of the LED or RGB strips we can set the matching colour It would be nice if in the side bar we could select an element and assign keyboard keys to it. e.g. z = left flipper, m = right flipper Basically this is a way to test rules \"offline\" and would be a really powerful feature for this application. Please could you create the full module and make it available as a zip. Can the component settings have the available events for this hardware type and be clickable to trigger the event. The key mapping will trigger the default event e.g. PRESS / PRESS HOLD / RELEASE etc for a button. In the component settings, could we have a size option, small, medium, large. which will resize the components. We don't need to get these exact but it would help with the mockup. e.g. LEDS will be small. Pop Bumpers large","excerpt":"I would like to create a new module, it should be the same structure as our existing ones with a split view.py and api.py. This module will emulate the pinball table and the components. I would like the content to have..."},{"slug":"2-technical-notes/specifications/ESPLink","path":"2-technical-notes/specifications/ESPLink.md","title":"ESPLink — Module Specification","order":10000,"html":"<h1>ESPLink — Module Specification</h1><h2>Overview</h2><p><strong>ESPLink</strong> is responsible for managing communication between the Raspberry Pi controller and one or more connected ESP32-S3 devices. It provides a web interface to view device information, monitor serial output, manage firmware updates, and perform diagnostic actions.</p><p>---</p><h2>Goals</h2><ul><li>Display status and metadata for connected ESP devices.</li><li>Manage multiple ESP connections.</li><li>List and apply available firmware versions.</li><li>Provide an inline upload console with real-time feedback.</li><li>Stream and control serial output from each ESP.</li><li>Offer common maintenance tools (reboot, sync time, backup config, etc).</li></ul><p>---</p><h2>User Interface</h2><h3>Top Bar (Sticky Header)</h3><ul><li><strong>Device Selector:</strong> Dropdown list of connected devices (<code>ESP_A1B2C3</code>, etc).</li><li><strong>Connection Status:</strong> “Connected / Disconnected” pill with last seen time.</li><li><strong>Firmware Version:</strong> <code>vX.Y.Z+build</code> reported by device.</li><li><strong>Chip Info:</strong> e.g. <code>ESP32-S3 | MAC: xx:xx:xx:xx:xx:xx</code>.</li><li><strong>Quick Actions:</strong> <code>Refresh</code>, <code>Reboot</code>, <code>Sync Time</code>, <code>Open Serial</code>.</li></ul><h3>Tabs / Sections</h3><ol><li><strong>Overview</strong></li></ol><ul><li>Live metrics: uptime, heap usage, temperature, Wi-Fi RSSI, IP, last fault.</li><li>Capabilities list (DMP, LEDs, I2C expanders, etc.).</li><li>Summary of loaded configuration (controller ID, features).</li></ul><ol><li><strong>Firmware</strong></li></ol><ul><li>Source selector: <code>Local dist/</code> | <code>Remote</code>.</li><li>List of available versions (from <code>versions.json</code>).</li><li>“Apply” button per version to start OTA update.</li><li>Inline <strong>Upload Console</strong>: step-by-step log output (autoscroll, downloadable).</li></ul><ol><li><strong>Serial</strong></li></ol><ul><li>Live serial stream viewer.</li><li>Controls: <strong>Start / Stop</strong>, <strong>Pause / Resume</strong>, <strong>Clear</strong>, <strong>Download</strong>, <strong>Follow tail</strong>.</li><li>Filters: include/exclude text, timestamps, baud (read-only if fixed).</li></ul><ol><li><strong>Tools</strong></li></ol><ul><li>Quick actions:</li><p><code>Reboot</code>, <code>Factory Reset</code>, <code>Backup Config</code>, <code>Restore Config</code>, <code>Ping</code>, <code>LED Test</code>, <code>I/O Monitor</code>, <code>Wi-Fi Scan</code>.</p></ul><p>---</p><h2>Firmware Management</h2><h3><code>versions.json</code> Schema</h3><pre><code>{\n  &quot;latest&quot;: &quot;1.2.3+45&quot;,\n  &quot;base_url&quot;: &quot;/static/dist/&quot;,\n  &quot;versions&quot;: [\n    {\n      &quot;version&quot;: &quot;1.2.3+45&quot;,\n      &quot;date&quot;: &quot;2025-11-07T12:34:56Z&quot;,\n      &quot;notes&quot;: &quot;Bugfixes and faster serial framing&quot;,\n      &quot;filename&quot;: &quot;firmware-1.2.3+45.bin&quot;,\n      &quot;sha256&quot;: &quot;…&quot;,\n      &quot;size&quot;: 1048576,\n      &quot;download_url&quot;: &quot;https://example.com/dist/firmware-1.2.3+45.bin&quot;\n    }\n  ]\n}</code></pre><p><strong>Rules</strong></p><ul><li>Prefer <code>download_url</code> if present, otherwise use <code>base_url + filename</code>.</li><li>The <code>latest</code> field marks the recommended build.</li></ul><h3>Local Paths</h3><ul><li>Development builds stored in:</li><p><code>pinballctl/web/static/dist/</code></p><li>Cached downloads:</li><p><code>~/.local/state/pinballctl/firmware-cache/</code></p></ul><p>---</p><h2>API Endpoints (prefix <code>/esplink</code>)</h2><h3>Devices</h3><p>| Method | Path | Description | |:--|:--|:--| | GET | <code>/devices</code> | List connected devices with basic info | | GET | <code>/devices/&lt;id&gt;/status</code> | Detailed device metrics | | POST | <code>/devices/&lt;id&gt;/reboot</code> | Soft-reboot device | | POST | <code>/devices/&lt;id&gt;/sync-time</code> | Sync RTC time with host |</p><h3>Firmware</h3><p>| Method | Path | Description | |:--|:--|:--| | GET | <code>/versions?source=local\\|remote</code> | Return merged version list | | POST | <code>/devices/&lt;id&gt;/upload</code> | Begin OTA upload (SSE/WebSocket progress) |</p><p><strong>Upload events:</strong></p><pre><code>STEP: download | verify | enter-ota | transfer 0–100 | commit | reboot | done\nLOG: arbitrary text line\nERROR: message</code></pre><h3>Serial</h3><p>| Method | Path | Description | |:--|:--|:--| | POST | <code>/devices/&lt;id&gt;/serial/start</code> | Begin streaming serial output | | POST | <code>/devices/&lt;id&gt;/serial/stop</code> | Stop serial session | | POST | <code>/devices/&lt;id&gt;/serial/pause</code> | Pause reading | | POST | <code>/devices/&lt;id&gt;/serial/resume</code> | Resume reading | | GET | <code>/devices/&lt;id&gt;/serial/stream</code> | Stream serial output via SSE/WS | | POST | <code>/devices/&lt;id&gt;/serial/write</code> | Optional: send command text |</p><h3>Config / Tools</h3><p>| Method | Path | Description | |:--|:--|:--| | GET | <code>/devices/&lt;id&gt;/config</code> | Download config | | POST | <code>/devices/&lt;id&gt;/config</code> | Apply config | | POST | <code>/devices/&lt;id&gt;/factory-reset</code> | Factory reset (with confirm) | | GET | <code>/devices/&lt;id&gt;/wifi/scan</code> | Return nearby Wi-Fi networks | | GET | <code>/ping</code> | Simple healthcheck |</p><p>---</p><h2>OTA Upload Flow</h2><ol><li><strong>Pause Serial</strong> — suspend logging.</li><li><strong>Fetch Firmware</strong> — local or remote download.</li><li><strong>Verify Hash</strong> — SHA-256 match if available.</li><li><strong>Enter OTA Mode</strong> — instruct device via bridge (<code>OTA_BEGIN size=&lt;n&gt; sha=&lt;…&gt;</code>).</li><li><strong>Transfer</strong> — chunked writes with progress, retry, throughput stats.</li><li><strong>Commit &amp; Reboot</strong> — <code>OTA_COMMIT</code>, then reboot.</li><li><strong>Reconnect &amp; Resume Serial</strong> — confirm new version.</li></ol><p>All steps output lines to the <strong>Upload Console</strong> (monospace, autoscroll, downloadable).</p><p>---</p><h2>Serial Console UX</h2><ul><li>Rolling buffer (e.g., 10 000 lines).</li><li>Optional timestamps.</li><li>Search / filter text.</li><li>Auto-follow toggle.</li><li>Pause automatically during OTA.</li></ul><p>---</p><h2>Multi-Device Handling</h2><ul><li>Devices listed from <code>/devices</code> (poll or WebSocket updates).</li><li>Each device keeps its own serial session and upload state.</li><li>Actions always include the device ID in path.</li></ul><p>---</p><h2>Frontend Structure</h2><ul><li>Route: <code>/esplink/</code></li><li>Framework: Alpine.js + WebAwesome.</li><li>Components:</li><li><code>esplink-header</code></li><li><code>esplink-overview</code></li><li><code>esplink-firmware</code></li><li><code>esplink-serial</code></li><li><code>esplink-tools</code></li><li>Console areas are flex cards with <code>overflow:auto;</code> and fixed height.</li></ul><p>---</p><h2>Bridge / Daemon Integration</h2><ul><li>Multiplex serial read/write with per-device pause/resume.</li><li>Emit <code>HELLO</code> payload: <code>{ fw, chip, mac, features, controller }</code>.</li><li>Rate-limit writes during OTA.</li><li>Normalize line endings (<code>\\n</code>) and timestamp at source.</li></ul><p>---</p><h2>Extra Tools &amp; Diagnostics</h2><ul><li><strong>Backup / Restore</strong> device configuration (JSON).</li><li><strong>Safe Mode / Rollback</strong> firmware if dual partitions exist.</li><li><strong>I/O Monitor</strong> — live switch &amp; coil states.</li><li><strong>LED Test</strong> — quick visual check patterns.</li><li><strong>Fault Snapshot</strong> — retrieve last crash dump.</li><li><strong>Time Sync</strong> &amp; <strong>NTP status</strong> view.</li><li><strong>Wi-Fi RSSI / Channel graph.</strong></li><li><strong>Manifest check</strong> before arming coils.</li><li><strong>Download serial transcript</strong> and <strong>upload log</strong> as text.</li></ul><p>---</p><h2>Security &amp; UX Notes</h2><ul><li>Confirmation prompts for destructive actions (reset, OTA).</li><li>CSRF protection on POST routes.</li><li>Verify size and SHA before flashing.</li><li>Require explicit user click to apply “latest”.</li><li>Optional <strong>dry-run verify</strong> mode (hash only, no write).</li></ul><p>---</p><p>_Last updated: November 2025_</p><h2>Original Requirements</h2><p>I think ESPLink may be more suitable. I would like this module to do the following:</p><ul><li>Display at the top information about the ESP. If it is connected, the version of firmware it is running etc. It may be that we have multiple devices connected so we should be able to select which one we are using. Any other information we can get from it should be displayed.</li></ul><ul><li>Firmware versions will be available during development in the dist folder in our project. We will create a versions.json which will have all the available versions and a &quot;latest&quot; which always points to the latest version. These versions will also have a link for download.  Going forward I will publish this dist to github so we should be able to retrive this list form a remote server. These versions should be listed and an option to Apply whic will upload to the ESP.</li></ul><ul><li>The upload status information should be displayed in an inline &quot;console&quot; window so we can see what is happening.</li></ul><ul><li>I would like to be able to view serial output from here. The UI may have a tab or button to open this up. When we upload we will need a way to pause the connection reading the serial.</li></ul><p>Can you think of any other tools here which might be useful to add to the UI ?</p>","plain":"ESPLink — Module Specification Overview ESPLink is responsible for managing communication between the Raspberry Pi controller and one or more connected ESP32-S3 devices. It provides a web interface to view device information, monitor serial output, manage firmware updates, and perform diagnostic actions. --- Goals Display status and metadata for connected ESP devices. Manage multiple ESP connections. List and apply available firmware versions. Provide an inline upload console with real-time feedback. Stream and control serial output from each ESP. Offer common maintenance tools reboot, sync time, backup config, etc . --- User Interface Top Bar Sticky Header Device Selector: Dropdown list of connected devices ESPA1B2C3, etc . Connection Status: “Connected / Disconnected” pill with last seen time. Firmware Version: vX.Y.Z+build reported by device. Chip Info: e.g. ESP32-S3 | MAC: xx:xx:xx:xx:xx:xx. Quick Actions: Refresh, Reboot, Sync Time, Open Serial. Tabs / Sections Overview Live metrics: uptime, heap usage, temperature, Wi-Fi RSSI, IP, last fault. Capabilities list DMP, LEDs, I2C expanders, etc. . Summary of loaded configuration controller ID, features . Firmware Source selector: Local dist/ | Remote. List of available versions from versions.json . “Apply” button per version to start OTA update. Inline Upload Console: step-by-step log output autoscroll, downloadable . Serial Live serial stream viewer. Controls: Start / Stop, Pause / Resume, Clear, Download, Follow tail. Filters: include/exclude text, timestamps, baud read-only if fixed . Tools Quick actions: Reboot, Factory Reset, Backup Config, Restore Config, Ping, LED Test, I/O Monitor, Wi-Fi Scan. --- Firmware Management versions.json Schema Rules Prefer downloadurl if present, otherwise use baseurl + filename. The latest field marks the recommended build. Local Paths Development builds stored in: pinballctl/web/static/dist/ Cached downloads: ~/.local/state/pinballctl/firmware-cache/ --- API Endpoints prefix /esplink Devices | Method | Path | Description | |:--|:--|:--| | GET | /devices | List connected devices with basic info | | GET | /devices/ /status | Detailed device metrics | | POST | /devices/ /reboot | Soft-reboot device | | POST | /devices/ /sync-time | Sync RTC time with host | Firmware | Method | Path | Description | |:--|:--|:--| | GET | /versions?source=local\\|remote | Return merged version list | | POST | /devices/ /upload | Begin OTA upload SSE/WebSocket progress | Upload events: Serial | Method | Path | Description | |:--|:--|:--| | POST | /devices/ /serial/start | Begin streaming serial output | | POST | /devices/ /serial/stop | Stop serial session | | POST | /devices/ /serial/pause | Pause reading | | POST | /devices/ /serial/resume | Resume reading | | GET | /devices/ /serial/stream | Stream serial output via SSE/WS | | POST | /devices/ /serial/write | Optional: send command text | Config / Tools | Method | Path | Description | |:--|:--|:--| | GET | /devices/ /config | Download config | | POST | /devices/ /config | Apply config | | POST | /devices/ /factory-reset | Factory reset with confirm | | GET | /devices/ /wifi/scan | Return nearby Wi-Fi networks | | GET | /ping | Simple healthcheck | --- OTA Upload Flow Pause Serial — suspend logging. Fetch Firmware — local or remote download. Verify Hash — SHA-256 match if available. Enter OTA Mode — instruct device via bridge OTABEGIN size= sha= . Transfer — chunked writes with progress, retry, throughput stats. Commit & Reboot — OTACOMMIT, then reboot. Reconnect & Resume Serial — confirm new version. All steps output lines to the Upload Console monospace, autoscroll, downloadable . --- Serial Console UX Rolling buffer e.g., 10 000 lines . Optional timestamps. Search / filter text. Auto-follow toggle. Pause automatically during OTA. --- Multi-Device Handling Devices listed from /devices poll or WebSocket updates . Each device keeps its own serial session and upload state. Actions always include the device ID in path. --- Frontend Structure Route: /esplink/ Framework: Alpine.js + WebAwesome. Components: esplink-header esplink-overview esplink-firmware esplink-serial esplink-tools Console areas are flex cards with overflow:auto; and fixed height. --- Bridge / Daemon Integration Multiplex serial read/write with per-device pause/resume. Emit HELLO payload: { fw, chip, mac, features, controller }. Rate-limit writes during OTA. Normalize line endings \\n and timestamp at source. --- Extra Tools & Diagnostics Backup / Restore device configuration JSON . Safe Mode / Rollback firmware if dual partitions exist. I/O Monitor — live switch & coil states. LED Test — quick visual check patterns. Fault Snapshot — retrieve last crash dump. Time Sync & NTP status view. Wi-Fi RSSI / Channel graph. Manifest check before arming coils. Download serial transcript and upload log as text. --- Security & UX Notes Confirmation prompts for destructive actions reset, OTA . CSRF protection on POST routes. Verify size and SHA before flashing. Require explicit user click to apply “latest”. Optional dry-run verify mode hash only, no write . --- Last updated: November 2025 Original Requirements I think ESPLink may be more suitable. I would like this module to do the following: Display at the top information about the ESP. If it is connected, the version of firmware it is running etc. It may be that we have multiple devices connected so we should be able to select which one we are using. Any other information we can get from it should be displayed. Firmware versions will be available during development in the dist folder in our project. We will create a versions.json which will have all the available versions and a \"latest\" which always points to the latest version. These versions will also have a link for download. Going forward I will publish this dist to github so we should be able to retrive this list form a remote server. These versions should be listed and an option to Apply whic will upload to the ESP. The upload status information should be displayed in an inline \"console\" window so we can see what is happening. I would like to be able to view serial output from here. The UI may have a tab or button to open this up. When we upload we will need a way to pause the connection reading the serial. Can you think of any other tools here which might be useful to add to the UI ?","excerpt":"ESPLink — Module Specification Overview ESPLink is responsible for managing communication between the Raspberry Pi controller and one or more connected ESP32-S3 devices. It provides a web interface to view device..."},{"slug":"2-technical-notes/specifications/EVENT_ENGINE","path":"2-technical-notes/specifications/EVENT_ENGINE.md","title":"Pinball Event to Action Engine","order":10000,"html":"<h1>Pinball Event-to-Action Engine</h1><p>This document describes an event/action engine that connects hardware events (like button presses) to actions (like firing coils or flashing lights) in the Pinball project.</p><p>------------------------------------------------------------------------</p><h2>Overview</h2><p>The engine: - Loads hardware mapping from <code>mapping.json</code> - Defines rules connecting input events to sequences of actions - Supports press/hold/release semantics for coils and buttons - Handles coil safety and timeouts - Sends commands to ESP bridge (HTTP or serial) - Can be embedded in <code>pinballctl</code> or run standalone</p><p>------------------------------------------------------------------------</p><h2>Example <code>mapping.json</code></h2><pre><code>{\n  &quot;hardware&quot;: {\n    &quot;L_FLIP_COIL&quot;: { &quot;type&quot;: &quot;coil&quot;, &quot;key&quot;: &quot;coil_01&quot;, &quot;max_on_ms&quot;: 150 },\n    &quot;L_FLIP_HOLD_COIL&quot;: { &quot;type&quot;: &quot;coil&quot;, &quot;key&quot;: &quot;coil_01&quot;, &quot;max_on_ms&quot;: 150 },\n    &quot;L_FLIP_LED&quot;: { &quot;type&quot;: &quot;led&quot;, &quot;key&quot;: &quot;led_05&quot; },\n    &quot;BUTTON_LEFT&quot;: { &quot;type&quot;: &quot;button&quot;, &quot;key&quot;: &quot;btn_02&quot; }\n  },\n  &quot;rules&quot;: [\n    {\n      &quot;name&quot;: &quot;Left Flipper (tap or hold)&quot;,\n      &quot;trigger&quot;: { &quot;event&quot;: &quot;BUTTON_LEFT_PRESSED&quot;, &quot;source&quot;: &quot;BUTTON_LEFT&quot; },\n      &quot;on_press&quot;: [\n        {\n          &quot;action&quot;: &quot;coil_pulse_or_hold&quot;,\n          &quot;params&quot;: {\n            &quot;coil&quot;: &quot;L_FLIP_COIL&quot;,\n            &quot;pulse_ms&quot;: 40,\n            &quot;hold_enabled&quot;: true,\n            &quot;hold_coil&quot;: &quot;L_FLIP_HOLD_COIL&quot;,\n            &quot;max_hold_ms&quot;: 150\n          }\n        },\n        {\n          &quot;action&quot;: &quot;led_flash&quot;,\n          &quot;params&quot;: { &quot;led&quot;: &quot;L_FLIP_LED&quot;, &quot;duration_ms&quot;: 100 }\n        }\n      ],\n      &quot;on_release&quot;: [\n        {\n          &quot;action&quot;: &quot;release_hold_coil&quot;,\n          &quot;params&quot;: { &quot;coil&quot;: &quot;L_FLIP_HOLD_COIL&quot; }\n        }\n      ]\n    }\n  ]\n}</code></pre><p>------------------------------------------------------------------------</p><h2><code>bridge_client.py</code></h2><pre><code># File: bridge_client.py\nimport requests\nfrom typing import Dict, Any\n\nclass BridgeClient:\n    def __init__(self, base_url: str = &quot;http://localhost:5001/bridge&quot;):\n        self.base_url = base_url.rstrip(&quot;/&quot;)\n\n    def send_command(self, device_key: str, command: str, params: Dict[str, Any] = None) -&gt; Dict[str, Any]:\n        url = f&quot;{self.base_url}/command&quot;\n        payload = {&quot;device_key&quot;: device_key, &quot;command&quot;: command, &quot;params&quot;: params or {}}\n        try:\n            r = requests.post(url, json=payload, timeout=1.5)\n            r.raise_for_status()\n            return r.json()\n        except Exception as e:\n            print(f&quot;[BridgeClient] send_command error: {e} payload={payload}&quot;)\n            return {&quot;ok&quot;: False, &quot;error&quot;: str(e)}</code></pre><p>------------------------------------------------------------------------</p><h2><code>actions.py</code></h2><pre><code># File: actions.py\nimport threading\nimport time\nfrom typing import Dict, Any, Optional\nfrom bridge_client import BridgeClient\n\nclass CoilState:\n    def __init__(self):\n        self.state = {}\n        self.lock = threading.Lock()\n\n    def ensure(self, coil_key):\n        with self.lock:\n            if coil_key not in self.state:\n                self.state[coil_key] = {&quot;last_on&quot;: 0.0, &quot;last_off&quot;: 0.0, &quot;is_on&quot;: False, &quot;lock&quot;: threading.Lock()}\n\n    def set_on(self, coil_key):\n        self.ensure(coil_key)\n        with self.state[coil_key][&quot;lock&quot;]:\n            self.state[coil_key][&quot;is_on&quot;] = True\n            self.state[coil_key][&quot;last_on&quot;] = time.time()\n\n    def set_off(self, coil_key):\n        self.ensure(coil_key)\n        with self.state[coil_key][&quot;lock&quot;]:\n            self.state[coil_key][&quot;is_on&quot;] = False\n            self.state[coil_key][&quot;last_off&quot;] = time.time()\n\ncoil_state = CoilState()\n\nclass Actions:\n    def __init__(self, mapping: Dict[str, Dict], bridge: BridgeClient):\n        self.mapping = mapping\n        self.bridge = bridge\n\n    def resolve_key(self, logical_name: str) -&gt; Optional[str]:\n        entry = self.mapping.get(logical_name)\n        if not entry:\n            print(f&quot;[Actions] unknown hardware name: {logical_name}&quot;)\n            return None\n        return entry.get(&quot;key&quot;)\n\n    def coil_on(self, logical_coil: str) -&gt; None:\n        coil_key = self.resolve_key(logical_coil)\n        if not coil_key:\n            return\n        coil_state.set_on(coil_key)\n        self.bridge.send_command(coil_key, &quot;coil_on&quot;, {})\n\n    def coil_off(self, logical_coil: str) -&gt; None:\n        coil_key = self.resolve_key(logical_coil)\n        if not coil_key:\n            return\n        self.bridge.send_command(coil_key, &quot;coil_off&quot;, {})\n        coil_state.set_off(coil_key)\n\n    def led_flash(self, logical_led: str, duration_ms: int = 100) -&gt; None:\n        led_key = self.resolve_key(logical_led)\n        if not led_key:\n            return\n        self.bridge.send_command(led_key, &quot;led_on&quot;, {})\n        t = threading.Timer(duration_ms / 1000.0, lambda: self.bridge.send_command(led_key, &quot;led_off&quot;, {}))\n        t.start()\n\n    def safe_coil_pulse(self, logical_coil: str, pulse_ms: int, max_on_ms: int = 200):\n        duration = min(pulse_ms, max_on_ms)\n        self.coil_on(logical_coil)\n        t = threading.Timer(duration / 1000.0, lambda: self.coil_off(logical_coil))\n        t.start()\n\n    def coil_pulse_or_hold(self, ctx: Dict[str, Any], params: Dict[str, Any]):\n        coil = params[&quot;coil&quot;]\n        pulse_ms = params.get(&quot;pulse_ms&quot;, 40)\n        hold_enabled = params.get(&quot;hold_enabled&quot;, False)\n        hold_coil = params.get(&quot;hold_coil&quot;, coil)\n        max_hold_ms = params.get(&quot;max_hold_ms&quot;, 150)\n        self.safe_coil_pulse(coil, pulse_ms, max_on_ms=max_hold_ms)\n        if hold_enabled:\n            def start_hold_after_pulse():\n                if ctx.get(&quot;released&quot;, False):\n                    return\n                self.coil_on(hold_coil)\n                t_off = threading.Timer(max_hold_ms / 1000.0, lambda: self.coil_off(hold_coil))\n                t_off.start()\n                ctx[&quot;hold_off_timer&quot;] = t_off\n            t_switch = threading.Timer(pulse_ms / 1000.0, start_hold_after_pulse)\n            t_switch.start()\n            ctx[&quot;hold_coil&quot;] = hold_coil\n\n    def release_hold_coil(self, ctx: Dict[str, Any], params: Dict[str, Any]):\n        coil = params[&quot;coil&quot;]\n        t = ctx.get(&quot;hold_off_timer&quot;)\n        if t and isinstance(t, threading.Timer):\n            t.cancel()\n        self.coil_off(coil)</code></pre><p>------------------------------------------------------------------------</p><h2><code>event_engine.py</code></h2><pre><code># File: event_engine.py\nimport json\nimport threading\nimport time\nfrom queue import Queue, Empty\nfrom typing import Dict, Any\nfrom bridge_client import BridgeClient\nfrom actions import Actions\n\nevent_queue = Queue()\n\nclass EventEngine:\n    def __init__(self, mapping_path: str, bridge_base: str = &quot;http://localhost:5001/bridge&quot;):\n        self.mapping_path = mapping_path\n        self.mapping = {}\n        self.rules = []\n        self.bridge = BridgeClient(bridge_base)\n        self.actions = None\n        self.running = False\n        self.worker_thread = None\n        self.active_contexts = {}\n        self._load_mapping()\n\n    def _load_mapping(self):\n        with open(self.mapping_path, &quot;r&quot;) as fh:\n            doc = json.load(fh)\n        self.mapping = doc.get(&quot;hardware&quot;, {})\n        self.rules = doc.get(&quot;rules&quot;, [])\n        self.actions = Actions(self.mapping, self.bridge)\n\n    def start(self):\n        self.running = True\n        self.worker_thread = threading.Thread(target=self._run_loop, daemon=True)\n        self.worker_thread.start()\n\n    def stop(self):\n        self.running = False\n        if self.worker_thread:\n            self.worker_thread.join(timeout=1.0)\n\n    def post_event(self, event: Dict[str, Any]):\n        event_queue.put(event)\n\n    def _run_loop(self):\n        while self.running:\n            try:\n                ev = event_queue.get(timeout=0.2)\n            except Empty:\n                continue\n            try:\n                self._handle_event(ev)\n            except Exception as e:\n                print(&quot;[EventEngine] error:&quot;, e)\n\n    def _handle_event(self, ev: Dict[str, Any]):\n        name = ev.get(&quot;event&quot;)\n        src = ev.get(&quot;source&quot;)\n        for rule in self.rules:\n            trig = rule.get(&quot;trigger&quot;, {})\n            if trig.get(&quot;event&quot;) != name:\n                continue\n            if &quot;source&quot; in trig and trig[&quot;source&quot;] != src:\n                continue\n            if name.endswith(&quot;_PRESSED&quot;):\n                ctx = {&quot;rule&quot;: rule.get(&quot;name&quot;), &quot;event&quot;: ev, &quot;released&quot;: False}\n                key = f&quot;{rule.get(&#x27;name&#x27;)}::{src}&quot;\n                self.active_contexts[key] = ctx\n                for act in rule.get(&quot;on_press&quot;, []):\n                    self._exec_action(ctx, act)\n            elif name.endswith(&quot;_RELEASED&quot;):\n                key = f&quot;{rule.get(&#x27;name&#x27;)}::{src}&quot;\n                ctx = self.active_contexts.get(key, {&quot;event&quot;: ev})\n                ctx[&quot;released&quot;] = True\n                for act in rule.get(&quot;on_release&quot;, []):\n                    self._exec_action(ctx, act)\n                if key in self.active_contexts:\n                    del self.active_contexts[key]\n\n    def _exec_action(self, ctx: Dict[str, Any], act: Dict[str, Any]):\n        name = act.get(&quot;action&quot;)\n        params = act.get(&quot;params&quot;, {})\n        if name == &quot;coil_pulse_or_hold&quot;:\n            self.actions.coil_pulse_or_hold(ctx, params)\n        elif name == &quot;release_hold_coil&quot;:\n            self.actions.release_hold_coil(ctx, params)\n        elif name == &quot;led_flash&quot;:\n            self.actions.led_flash(params.get(&quot;led&quot;), params.get(&quot;duration_ms&quot;, 100))\n        else:\n            self.actions.run_action(name, ctx, params)</code></pre><p>------------------------------------------------------------------------</p><h2>Integration</h2><ul><li>The ESP bridge should POST events such as:</li></ul><pre><code>    { &quot;event&quot;: &quot;BUTTON_LEFT_PRESSED&quot;, &quot;source&quot;: &quot;BUTTON_LEFT&quot;, &quot;ts&quot;: 169... }</code></pre><ul><li><code>BridgeClient</code> sends commands to ESP via <code>/bridge/command</code> endpoint</li><p>or serial.</p></ul><ul><li>Put <code>mapping.json</code> under your instance path (same as</li><p><code>hardware/api.py</code>).</p></ul><p>------------------------------------------------------------------------</p><h2>Safety Recommendations</h2><ul><li>Enforce coil <code>max_on_ms</code> in both ESP firmware and the Pi.</li><li>Implement minimum off-time between pulses.</li><li>Add watchdog to disable coils on fault.</li><li>Extend coil state tracking to detect overheat or missed release.</li></ul><p>------------------------------------------------------------------------</p><h2>Next Steps</h2><ul><li>Add UI for rule editing</li><li>Add conditional logic and sequences</li><li>Integrate event logging with your <code>LogManager</code></li><li>Simulate hardware for testing</li></ul><p>------------------------------------------------------------------------</p>","plain":"Pinball Event-to-Action Engine This document describes an event/action engine that connects hardware events like button presses to actions like firing coils or flashing lights in the Pinball project. ------------------------------------------------------------------------ Overview The engine: - Loads hardware mapping from mapping.json - Defines rules connecting input events to sequences of actions - Supports press/hold/release semantics for coils and buttons - Handles coil safety and timeouts - Sends commands to ESP bridge HTTP or serial - Can be embedded in pinballctl or run standalone ------------------------------------------------------------------------ Example mapping.json ------------------------------------------------------------------------ bridgeclient.py ------------------------------------------------------------------------ actions.py ------------------------------------------------------------------------ eventengine.py ------------------------------------------------------------------------ Integration The ESP bridge should POST events such as: BridgeClient sends commands to ESP via /bridge/command endpoint or serial. Put mapping.json under your instance path same as hardware/api.py . ------------------------------------------------------------------------ Safety Recommendations Enforce coil maxonms in both ESP firmware and the Pi. Implement minimum off-time between pulses. Add watchdog to disable coils on fault. Extend coil state tracking to detect overheat or missed release. ------------------------------------------------------------------------ Next Steps Add UI for rule editing Add conditional logic and sequences Integrate event logging with your LogManager Simulate hardware for testing ------------------------------------------------------------------------","excerpt":"Pinball Event-to-Action Engine This document describes an event/action engine that connects hardware events like button presses to actions like firing coils or flashing lights in the Pinball project...."},{"slug":"2-technical-notes/specifications/LIGHTING","path":"2-technical-notes/specifications/LIGHTING.md","title":"Lighting Module – Technical Specification (Draft)","order":10000,"html":"<h1>Lighting Module – Technical Specification (Draft)</h1><h2>1. Purpose</h2><p>The <strong>Lighting Module</strong> provides centralized control over all illuminated elements on the pinball machine. Rather than toggling individual LEDs, the module defines <strong>lighting groups</strong> and <strong>sequences</strong> that can be triggered by rules, creating coordinated lighting effects and animations.</p><p>It forms the foundation for:</p><ul><li>Dynamic light shows (e.g., attract mode, multiball, bonus count)</li><li>Real-time response to gameplay events (targets, bumpers, launches)</li><li>Timeline-based sequencing and layered playback</li></ul><p>---</p><h2>2. Core Concepts</h2><h3>2.1 Lighting Groups</h3><p>A <strong>Lighting Group</strong> (working name: <em>Light Group</em>, <em>Channel</em>, or <em>Fixture Group</em>) represents a logical collection of LEDs or strips.</p><p>Each group has:</p><ul><li><strong>Name / ID</strong></li><li><strong>Hardware mapping</strong> (one or more LEDs or LED strips)</li><li><strong>Type</strong></li><li><code>single</code> – individual RGB or mono LED</li><li><code>strip</code> – addressable LED strip (e.g., 30 LEDs)</li><li><code>matrix</code> (future) – 2D panel or complex zone</li><li><strong>Default color / state</strong></li><li><strong>Capabilities</strong> – e.g. RGB, brightness control, patterns supported</li></ul><p>Lighting groups abstract the hardware so sequences can target logical groups instead of raw pins.</p><p>---</p><h3>2.2 Patterns</h3><p>A <strong>Pattern</strong> defines a behavior or animation that can be applied to a group. Patterns may be static, timed, or continuous.</p><p><strong>Examples:</strong></p><ul><li><strong>Static</strong></li><p><code>On Red</code>, <code>Off</code>, <code>On Blue 500ms</code></p><li><strong>Transition</strong></li><p><code>Fade to color over [n] ms</code>, <code>Pulse</code></p><li><strong>Looped / Animated</strong></li><p><code>Chase</code>, <code>Rainbow</code>, <code>Knight Rider</code>, <code>Sparkle</code>, <code>Fill-Drain</code></p></ul><p>Each pattern includes:</p><ul><li><code>type</code> (enum)</li><li><code>duration</code> (optional)</li><li><code>color(s)</code></li><li><code>parameters</code> (speed, brightness, direction)</li><li><code>behavior</code> (<code>loop</code>, <code>once</code>, <code>fade</code>, etc.)</li></ul><p>---</p><h3>2.3 Sequences</h3><p>A <strong>Sequence</strong> is a timeline of lighting actions applied to one or more groups. It defines what happens <strong>over time</strong> — like a mini show.</p><p><strong>Structure:</strong></p><pre><code>{\n  &quot;name&quot;: &quot;Launch Sequence&quot;,\n  &quot;duration&quot;: 5000,\n  &quot;tracks&quot;: [\n    {\n      &quot;group&quot;: &quot;LeftStrip&quot;,\n      &quot;events&quot;: [\n        { &quot;time&quot;: 0, &quot;pattern&quot;: &quot;On Red&quot; },\n        { &quot;time&quot;: 1000, &quot;pattern&quot;: &quot;FadeOff&quot;, &quot;duration&quot;: 800 }\n      ]\n    },\n    {\n      &quot;group&quot;: &quot;PlayfieldGI&quot;,\n      &quot;events&quot;: [\n        { &quot;time&quot;: 0, &quot;pattern&quot;: &quot;Rainbow&quot;, &quot;duration&quot;: 4000 }\n      ]\n    }\n  ]\n}</code></pre><p>Each track controls one lighting group over a timeline. Multiple sequences can run simultaneously.</p><p>---</p><h3>2.4 Scenes</h3><p>A <strong>Scene</strong> represents a reusable lighting setup or “mode,” e.g.:</p><ul><li><code>Attract</code></li><li><code>Gameplay</code></li><li><code>Multiball</code></li><li><code>Launch</code></li><li><code>Bonus</code></li></ul><p>Scenes reference one or more sequences and define how they interact (overlay, interrupt, fade in/out).</p><p>---</p><h2>3. Interaction Model</h2><h3>3.1 Rule Integration</h3><p>Rules trigger lighting actions:</p><pre><code>{\n  &quot;rule&quot;: &quot;Launch&quot;,\n  &quot;trigger&quot;: &quot;LaunchButtonPressed&quot;,\n  &quot;actions&quot;: [\n    { &quot;type&quot;: &quot;fire_coil&quot;, &quot;id&quot;: &quot;LaunchCoil&quot; },\n    { &quot;type&quot;: &quot;play_sound&quot;, &quot;file&quot;: &quot;rocket.wav&quot; },\n    { &quot;type&quot;: &quot;start_lighting&quot;, &quot;sequence&quot;: &quot;Launch&quot; }\n  ]\n}</code></pre><p>Lighting actions are sent to the lighting engine with parameters:</p><ul><li><code>sequence</code>: name or ID</li><li><code>mode</code>: <code>overlay | replace | interrupt</code></li><li><code>layer</code>: optional numeric priority (for layering)</li></ul><p>---</p><h3>3.2 Playback Modes</h3><p>| Mode | Description | |------|--------------| | <strong>Replace</strong> | Stops current lighting and plays new sequence exclusively | | <strong>Overlay</strong> | Adds on top of existing sequences; both render together | | <strong>Interrupt</strong> | Pauses background sequence, runs temporary effect, then resumes | | <strong>Additive (future)</strong> | Blends light values instead of replacing them |</p><p>---</p><h2>4. Editor UI (Web)</h2><p>The web interface (Flask + Alpine.js) will evolve to include:</p><h3>4.1 Sequence Timeline View</h3><ul><li>Displays the <strong>Playfield table view</strong> (read-only background)</li><li>Selects LEDs or groups visually</li><li>Shows time axis at bottom</li><li>Add, move, or resize lighting “blocks” representing patterns</li><li>Scrub/play preview over time</li></ul><h3>4.2 Scene Management</h3><ul><li>List of available scenes (Attract, Gameplay, Bonus, etc.)</li><li>Buttons: <code>Create</code>, <code>Edit</code>, <code>Duplicate</code>, <code>Delete</code></li><li>For each scene:</li><li>Assign included sequences</li><li>Define transition/overlay behavior</li></ul><h3>4.3 Pattern Editor</h3><ul><li>Visual configuration for custom patterns</li><li>Preview color, speed, direction</li></ul><p>---</p><h2>5. Runtime Behavior (Backend + ESP)</h2><p>| Component | Responsibility | |------------|----------------| | <strong>Pi (Flask / pinballctl)</strong> | Defines, stores, and triggers lighting sequences | | <strong>ESP32 Firmware</strong> | Receives pattern and group data, executes animations in real time | | <strong>Bridge</strong> | Translates scene/sequence events from Flask to ESP messages | | <strong>Rules Engine</strong> | Fires lighting triggers via <code>start_lighting</code> actions |</p><p>Example bridge command:</p><pre><code>LIGHTSEQ START name=Launch mode=overlay</code></pre><p>or direct group command:</p><pre><code>LIGHTGROUP SET group=LeftStrip pattern=Rainbow duration=4000</code></pre><h3>5.1 Runtime Layering Model (Reference)</h3><p>The runtime model should support <strong>multiple active scene instances</strong> and resolve output per fixture/pixel every tick.</p><p>Primary goals:</p><ul><li>Keep a low-priority base scene running (<code>Attract</code>, <code>InGame</code>).</li><li>Allow temporary overlays (<code>Bonus</code>, <code>Mode</code>, <code>Jackpot</code>) to take control of only their cast.</li><li>Support interrupt behavior: pause underlying scene(s), play insert scene, resume exactly where paused.</li></ul><h4>5.1.1 Active Scene Instances</h4><p>Each active scene instance tracks:</p><ul><li><code>sceneId</code></li><li><code>instanceId</code></li><li><code>priority</code> (higher wins)</li><li><code>state</code> (<code>running | paused | stopped | completed</code>)</li><li><code>clockMs</code> (frozen while paused)</li><li><code>startedAtMs</code></li><li><code>cast</code> (fixture/pixel scope)</li><li><code>onComplete</code> policy</li></ul><p>Notes:</p><ul><li>Multiple instances of different scenes may run concurrently.</li><li>By default, one scene may have at most one active instance unless explicitly allowed.</li></ul><h4>5.1.2 Ownership and Arbitration</h4><p>For each fixture/pixel output slot:</p><ol><li>Collect all active scene instances that currently address that slot.</li><li>Select the highest-priority active writer.</li><li>Apply that writer’s value.</li><li>If no active writer exists, fall through to lower layers, then default/off.</li></ol><p>This gives deterministic behavior where <code>Bonus</code> can temporarily take control of inserts also used by <code>InGame</code>.</p><h4>5.1.3 Playback Policies</h4><p>Recommended start modes:</p><ul><li><code>replace</code>: stop all lower/equal-priority scenes and start new scene.</li><li><code>overlay</code>: start scene without stopping others; arbitration handles conflicts.</li><li><code>interrupt</code>: pause selected underlying scenes, run new scene, resume paused scenes on completion.</li></ul><p>Recommended completion policies:</p><ul><li><code>stop</code>: scene ends; no follow-up action.</li><li><code>resume_under</code>: resume scenes paused by this instance.</li><li><code>restore_snapshot</code> (future): restore exact output snapshot before interrupt.</li></ul><h4>5.1.4 Time Semantics</h4><ul><li>Scene clocks advance only when <code>running</code>.</li><li><code>paused</code> scenes keep their current frame/time and continue from that exact point when resumed.</li><li><code>repeat</code> and <code>bounce</code> behavior remains scene-local and should not affect other scene clocks.</li></ul><h4>5.1.5 Precompiled Data and Metadata</h4><p>Scenes remain precompiled linear instructions, with runtime metadata attached per scene:</p><ul><li><code>priority</code> (default low for base scenes)</li><li><code>cast</code> mask/scope</li><li><code>blendMode</code> (start with <code>override</code> only)</li><li><code>onComplete</code> policy</li></ul><p>Initial implementation guidance:</p><ul><li>Start with <code>override</code> blending only.</li><li>Add additive/max blend modes only after deterministic override layering is stable.</li></ul><h4>5.1.6 ESP/Pi Responsibility Split</h4><ul><li><strong>Pi</strong>: authoring, validation, compile, orchestration requests.</li><li><strong>ESP</strong>: real-time scene-instance scheduler, arbitration, safety-constrained output.</li></ul><p>The ESP runtime should be the authority for final per-tick output resolution.</p><h4>5.1.7 Control Command Shape (Framed JSON)</h4><p>All runtime control commands must use framed JSON transport.</p><p>Suggested control set:</p><ul><li><code>SCENE_START</code> <code>{sceneId, mode, priority?, onComplete?, instanceId?}</code></li><li><code>SCENE_STOP</code> <code>{sceneId|instanceId|all}</code></li><li><code>SCENE_PAUSE</code> <code>{sceneId|instanceId}</code></li><li><code>SCENE_RESUME</code> <code>{sceneId|instanceId}</code></li><li><code>SCENE_STATUS</code> / <code>GET_SCENE_STATUS</code> (active instances, states, priorities, clocks)</li></ul><p>This supports:</p><ul><li><code>Attract -&gt; InGame</code> transitions,</li><li>overlay feedback scenes (e.g. bonus inserts),</li><li>pause/play inserts that resume the main scene cleanly.</li></ul><p>---</p><h2>6. Hardware Integration</h2><p>Lighting groups map to hardware via the <strong>Hardware Module</strong>:</p><ul><li>Each hardware entry may declare a lighting capability:</li><li><code>type</code>: <code>single | strip</code></li><li><code>rgb</code>: true/false</li><li><code>count</code>: number of addressable LEDs (if strip)</li><li>This metadata informs the Lighting Module what patterns are valid for that group.</li></ul><p>If unspecified, defaults to a single RGB LED.</p><p>---</p><h2>7. File &amp; Data Structure</h2><p>| File | Purpose | |------|----------| | <code>lighting/groups.json</code> | Defines lighting groups and hardware mappings | | <code>lighting/patterns.json</code> | Stores reusable pattern templates | | <code>lighting/sequences.json</code> | Stores timeline-based sequences | | <code>lighting/scenes.json</code> | Defines scene configurations (collections of sequences) |</p><p>All files share the same versioning system used in other modules.</p><p>---</p><h2>8. Future Extensions</h2><p>| Feature | Description | |----------|--------------| | <strong>Live Preview</strong> | Play sequences directly in the Playfield table | | <strong>Beat Sync</strong> | Time lighting to music or sound effects | | <strong>Conditional Logic</strong> | Sequence branches depending on game state | | <strong>Parameter Modulation</strong> | Control brightness or hue dynamically via gameplay variables | | <strong>Hardware Discovery</strong> | Auto-map LED strips and bulbs from ESP report | | <strong>Palette System</strong> | Define reusable color sets and gradients |</p><p>---</p><h2>9. Design Notes</h2><ul><li>The <strong>Lighting Module</strong> will <strong>not</strong> control individual bulbs directly; it manages logical groups.</li><li>Sequences will support <strong>nested playback</strong>, allowing a &quot;global&quot; ambient pattern with localized effects layered on top.</li><li>The playback engine must maintain frame consistency — ideally at 30–60Hz — but interpolate smoothly when triggered by low-frequency events.</li><li>Timekeeping and blending are handled on the Pi for preview; ESP runs lightweight interpreted pattern commands for real output.</li></ul><p>---</p><h2>10. Naming Ideas for “Lighting Groups”</h2><p>Candidate terms (choose one standard name):</p><ul><li><strong>Fixture</strong></li><li><strong>Channel</strong></li><li><strong>Zone</strong></li><li><strong>Light Group</strong></li><li><strong>Lighting Node</strong></li><li><strong>Cluster</strong></li></ul><p>(Recommended: <strong>Fixture</strong> — it’s standard in lighting design and scales well to multi-LED strips or logical regions.)</p><p>---</p><h2>11. Development Phases</h2><p>| Phase | Scope | |-------|--------| | <strong>Phase 1</strong> | Define schema + CRUD for groups, patterns, sequences, and scenes | | <strong>Phase 2</strong> | Basic UI to create and trigger patterns manually | | <strong>Phase 3</strong> | Timeline editor + table visualization | | <strong>Phase 4</strong> | Runtime integration with rule system | | <strong>Phase 5</strong> | Real-time bridge integration with ESP for live playback |</p><h2>Original Requirements</h2><p>The next module I would like to create is for lighting. I am not quite sure how this one is going to go or how easy it would be. Here are my thoughts.</p><p>Rather than controlling and changing individual bulbs and LED strips I would like to setup [find a name to describe lighting groups] that define patterns, this could be a simple &quot;On Red&quot;, &quot;Off&quot; and start to get more complex &quot;On and Red for [n] ms, fade off over [n] ms&quot; or apply patterns such as rainbow, chase.</p><p>Eventually I would like to create an option where we create a time line and over time we can turn stuff on, off or select a pattern to play over a subset of the time.</p><p>It would be great to have the table displayed (From the Playfield) From here individual leds or strips can be selected and the on/off or colour selected for that moment in time. We can then scrub, play the sequence and it will be visually displayed. None light elements would be displayed but faded out.</p><p>From this we can then create scenes for &quot;Attract&quot;, Bonus, etc</p><p>The Rules will then trigger these lighting displays.</p><p>Rule: Launch Triggered by &quot;Launch Button Press&quot; Actions:</p><ul><li>Fire Launch solanoid</li><li>Play rocket sound</li><li>Trigger &quot;Launch lighting&quot;</li></ul><p>Random thoughts:</p><ul><li>Sequence&#x27;s will need to be configured with a light type, single LED or Strip. If a strip is it RGB and how many LEDs does it have. Will we need to update the harware module so when we map a type we know how many bulbs it has .. or dont we care and just let the lighting module deal with it.</li></ul><ul><li>How do overlaps work. We might have a &quot;In game&quot; sequence playing. But then the launch sequence is started. Does this STOP or Pause the gameplay sequence, play the launch then continue with the gameplay. We could potentially have multiple layers. A target is hit with flashed the &quot;target&quot; leds making them flash, but we still want the game play sequence to stay running.</li></ul><p>These leads me to think about if a sequence &quot;overlays&quot; or interrupts, or replaces.</p><p>I dont want you to code this yet. I want to create a requirements and specification on this with you padding it out and making it a suitable technical spec covering as much detail as possible. Please keep the formatting simple and in a way I can present it back to you when I am ready for the module to be created.</p>","plain":"Lighting Module – Technical Specification Draft Purpose The Lighting Module provides centralized control over all illuminated elements on the pinball machine. Rather than toggling individual LEDs, the module defines lighting groups and sequences that can be triggered by rules, creating coordinated lighting effects and animations. It forms the foundation for: Dynamic light shows e.g., attract mode, multiball, bonus count Real-time response to gameplay events targets, bumpers, launches Timeline-based sequencing and layered playback --- Core Concepts 2.1 Lighting Groups A Lighting Group working name: Light Group, Channel, or Fixture Group represents a logical collection of LEDs or strips. Each group has: Name / ID Hardware mapping one or more LEDs or LED strips Type single – individual RGB or mono LED strip – addressable LED strip e.g., 30 LEDs matrix future – 2D panel or complex zone Default color / state Capabilities – e.g. RGB, brightness control, patterns supported Lighting groups abstract the hardware so sequences can target logical groups instead of raw pins. --- 2.2 Patterns A Pattern defines a behavior or animation that can be applied to a group. Patterns may be static, timed, or continuous. Examples: Static On Red, Off, On Blue 500ms Transition Fade to color over n ms, Pulse Looped / Animated Chase, Rainbow, Knight Rider, Sparkle, Fill-Drain Each pattern includes: type enum duration optional color s parameters speed, brightness, direction behavior loop, once, fade, etc. --- 2.3 Sequences A Sequence is a timeline of lighting actions applied to one or more groups. It defines what happens over time — like a mini show. Structure: Each track controls one lighting group over a timeline. Multiple sequences can run simultaneously. --- 2.4 Scenes A Scene represents a reusable lighting setup or “mode,” e.g.: Attract Gameplay Multiball Launch Bonus Scenes reference one or more sequences and define how they interact overlay, interrupt, fade in/out . --- Interaction Model 3.1 Rule Integration Rules trigger lighting actions: Lighting actions are sent to the lighting engine with parameters: sequence: name or ID mode: overlay | replace | interrupt layer: optional numeric priority for layering --- 3.2 Playback Modes | Mode | Description | |------|--------------| | Replace | Stops current lighting and plays new sequence exclusively | | Overlay | Adds on top of existing sequences; both render together | | Interrupt | Pauses background sequence, runs temporary effect, then resumes | | Additive future | Blends light values instead of replacing them | --- Editor UI Web The web interface Flask + Alpine.js will evolve to include: 4.1 Sequence Timeline View Displays the Playfield table view read-only background Selects LEDs or groups visually Shows time axis at bottom Add, move, or resize lighting “blocks” representing patterns Scrub/play preview over time 4.2 Scene Management List of available scenes Attract, Gameplay, Bonus, etc. Buttons: Create, Edit, Duplicate, Delete For each scene: Assign included sequences Define transition/overlay behavior 4.3 Pattern Editor Visual configuration for custom patterns Preview color, speed, direction --- Runtime Behavior Backend + ESP | Component | Responsibility | |------------|----------------| | Pi Flask / pinballctl | Defines, stores, and triggers lighting sequences | | ESP32 Firmware | Receives pattern and group data, executes animations in real time | | Bridge | Translates scene/sequence events from Flask to ESP messages | | Rules Engine | Fires lighting triggers via startlighting actions | Example bridge command: or direct group command: 5.1 Runtime Layering Model Reference The runtime model should support multiple active scene instances and resolve output per fixture/pixel every tick. Primary goals: Keep a low-priority base scene running Attract, InGame . Allow temporary overlays Bonus, Mode, Jackpot to take control of only their cast. Support interrupt behavior: pause underlying scene s , play insert scene, resume exactly where paused. 5.1.1 Active Scene Instances Each active scene instance tracks: sceneId instanceId priority higher wins state running | paused | stopped | completed clockMs frozen while paused startedAtMs cast fixture/pixel scope onComplete policy Notes: Multiple instances of different scenes may run concurrently. By default, one scene may have at most one active instance unless explicitly allowed. 5.1.2 Ownership and Arbitration For each fixture/pixel output slot: Collect all active scene instances that currently address that slot. Select the highest-priority active writer. Apply that writer’s value. If no active writer exists, fall through to lower layers, then default/off. This gives deterministic behavior where Bonus can temporarily take control of inserts also used by InGame. 5.1.3 Playback Policies Recommended start modes: replace: stop all lower/equal-priority scenes and start new scene. overlay: start scene without stopping others; arbitration handles conflicts. interrupt: pause selected underlying scenes, run new scene, resume paused scenes on completion. Recommended completion policies: stop: scene ends; no follow-up action. resumeunder: resume scenes paused by this instance. restoresnapshot future : restore exact output snapshot before interrupt. 5.1.4 Time Semantics Scene clocks advance only when running. paused scenes keep their current frame/time and continue from that exact point when resumed. repeat and bounce behavior remains scene-local and should not affect other scene clocks. 5.1.5 Precompiled Data and Metadata Scenes remain precompiled linear instructions, with runtime metadata attached per scene: priority default low for base scenes cast mask/scope blendMode start with override only onComplete policy Initial implementation guidance: Start with override blending only. Add additive/max blend modes only after deterministic override layering is stable. 5.1.6 ESP/Pi Responsibility Split Pi: authoring, validation, compile, orchestration requests. ESP: real-time scene-instance scheduler, arbitration, safety-constrained output. The ESP runtime should be the authority for final per-tick output resolution. 5.1.7 Control Command Shape Framed JSON All runtime control commands must use framed JSON transport. Suggested control set: SCENESTART {sceneId, mode, priority?, onComplete?, instanceId?} SCENESTOP {sceneId|instanceId|all} SCENEPAUSE {sceneId|instanceId} SCENERESUME {sceneId|instanceId} SCENESTATUS / GETSCENESTATUS active instances, states, priorities, clocks This supports: Attract -> InGame transitions, overlay feedback scenes e.g. bonus inserts , pause/play inserts that resume the main scene cleanly. --- Hardware Integration Lighting groups map to hardware via the Hardware Module: Each hardware entry may declare a lighting capability: type: single | strip rgb: true/false count: number of addressable LEDs if strip This metadata informs the Lighting Module what patterns are valid for that group. If unspecified, defaults to a single RGB LED. --- File & Data Structure | File | Purpose | |------|----------| | lighting/groups.json | Defines lighting groups and hardware mappings | | lighting/patterns.json | Stores reusable pattern templates | | lighting/sequences.json | Stores timeline-based sequences | | lighting/scenes.json | Defines scene configurations collections of sequences | All files share the same versioning system used in other modules. --- Future Extensions | Feature | Description | |----------|--------------| | Live Preview | Play sequences directly in the Playfield table | | Beat Sync | Time lighting to music or sound effects | | Conditional Logic | Sequence branches depending on game state | | Parameter Modulation | Control brightness or hue dynamically via gameplay variables | | Hardware Discovery | Auto-map LED strips and bulbs from ESP report | | Palette System | Define reusable color sets and gradients | --- Design Notes The Lighting Module will not control individual bulbs directly; it manages logical groups. Sequences will support nested playback, allowing a \"global\" ambient pattern with localized effects layered on top. The playback engine must maintain frame consistency — ideally at 30–60Hz — but interpolate smoothly when triggered by low-frequency events. Timekeeping and blending are handled on the Pi for preview; ESP runs lightweight interpreted pattern commands for real output. --- Naming Ideas for “Lighting Groups” Candidate terms choose one standard name : Fixture Channel Zone Light Group Lighting Node Cluster Recommended: Fixture — it’s standard in lighting design and scales well to multi-LED strips or logical regions. --- Development Phases | Phase | Scope | |-------|--------| | Phase 1 | Define schema + CRUD for groups, patterns, sequences, and scenes | | Phase 2 | Basic UI to create and trigger patterns manually | | Phase 3 | Timeline editor + table visualization | | Phase 4 | Runtime integration with rule system | | Phase 5 | Real-time bridge integration with ESP for live playback | Original Requirements The next module I would like to create is for lighting. I am not quite sure how this one is going to go or how easy it would be. Here are my thoughts. Rather than controlling and changing individual bulbs and LED strips I would like to setup find a name to describe lighting groups that define patterns, this could be a simple \"On Red\", \"Off\" and start to get more complex \"On and Red for n ms, fade off over n ms\" or apply patterns such as rainbow, chase. Eventually I would like to create an option where we create a time line and over time we can turn stuff on, off or select a pattern to play over a subset of the time. It would be great to have the table displayed From the Playfield From here individual leds or strips can be selected and the on/off or colour selected for that moment in time. We can then scrub, play the sequence and it will be visually displayed. None light elements would be displayed but faded out. From this we can then create scenes for \"Attract\", Bonus, etc The Rules will then trigger these lighting displays. Rule: Launch Triggered by \"Launch Button Press\" Actions: Fire Launch solanoid Play rocket sound Trigger \"Launch lighting\" Random thoughts: Sequence's will need to be configured with a light type, single LED or Strip. If a strip is it RGB and how many LEDs does it have. Will we need to update the harware module so when we map a type we know how many bulbs it has .. or dont we care and just let the lighting module deal with it. How do overlaps work. We might have a \"In game\" sequence playing. But then the launch sequence is started. Does this STOP or Pause the gameplay sequence, play the launch then continue with the gameplay. We could potentially have multiple layers. A target is hit with flashed the \"target\" leds making them flash, but we still want the game play sequence to stay running. These leads me to think about if a sequence \"overlays\" or interrupts, or replaces. I dont want you to code this yet. I want to create a requirements and specification on this with you padding it out and making it a suitable technical spec covering as much detail as possible. Please keep the formatting simple and in a way I can present it back to you when I am ready for the module to be created.","excerpt":"Lighting Module – Technical Specification Draft Purpose The Lighting Module provides centralized control over all illuminated elements on the pinball machine. Rather than toggling individual LEDs, the module defines..."},{"slug":"2-technical-notes/specifications/MAINTAINER","path":"2-technical-notes/specifications/MAINTAINER.md","title":"MAINTAINER GUIDE — pinballctl","order":10000,"html":"<h1>MAINTAINER GUIDE — pinballctl</h1><p>This document is for project maintainers. It covers versioning, building, and publishing releases using the <strong>maintainer-only</strong> script: <code>utils/build-release.sh</code>.</p><p>---</p><h2>Prerequisites</h2><ul><li><strong>GitHub CLI</strong>: <code>gh</code> installed and authenticated</li></ul><pre><code>  gh auth login    # or export GH_TOKEN/GITHUB_TOKEN</code></pre><ul><li><strong>Python</strong>: 3.11+ recommended (for <code>tomllib</code> parsing in the script)</li><li><strong>Build tooling</strong>:</li></ul><pre><code>  python -m pip install --upgrade build</code></pre><p>&gt; The public CLI (<code>pinballctl</code>) intentionally contains <strong>no</strong> release/publish commands. Release operations are <strong>maintainer-only</strong> via the script.</p><p>---</p><h2>Versioning &amp; Changelog</h2><ul><li>Follow <strong>Semantic Versioning</strong>: <code>MAJOR.MINOR.PATCH</code> (e.g., <code>0.1.1</code>).</li><li>Bump the version in <code>pyproject.toml</code>:</li></ul><pre><code>  [project]\n  version = &quot;0.1.1&quot;</code></pre><ul><li>Update <strong><code>CHANGELOG.md</code></strong> with a new section at the top:</li></ul><pre><code>  ## [v0.1.1] - 2025-11-02\n  ### Added\n  - New feature...\n\n  ### Changed\n  - Behavior change...\n\n  ### Fixed\n  - Bug fix...</code></pre><p>&gt; The release script extracts the section matching the <strong>exact version</strong> (<code>## 0.1.1</code>, <code>## v0.1.1</code>, or <code>## [0.1.1]</code>). If not found, it can use <code>--generate 1</code> or fallback <code>--notes</code>/<code>--notes-file</code>.</p><p>---</p><h2>Building &amp; Releasing</h2><p>The maintainer script builds <strong>sdist + wheel</strong>, tags using <code>vX.Y.Z</code>, and creates a GitHub release.</p><h3>Normal Release (Latest by default)</h3><pre><code>./utils/build-release.sh</code></pre><ul><li>Uses <code>CHANGELOG.md</code> to populate notes.</li><li>Creates tag <code>v&lt;version&gt;</code> if needed and pushes it.</li><li>Creates a GitHub release and uploads artifacts.</li><li>Marks as <strong>latest</strong>, unless you specify otherwise with <code>--latest 0</code>.</li></ul><h3>Pre-release</h3><p>GitHub does <strong>not</strong> allow a prerelease to be marked as latest. The script auto-disables <code>--latest</code> when <code>--prerelease 1</code> is set.</p><pre><code>./utils/build-release.sh --prerelease 1\n# (implicitly behaves as --latest 0)</code></pre><h3>Replace Existing Release (Overwrite Assets)</h3><p>If a release already exists for this tag, the default behavior is to <strong>fail</strong> safely. Pass <code>--replace 1</code> to overwrite (clobber) the assets in-place:</p><pre><code>./utils/build-release.sh --replace 1</code></pre><p>&gt; Notes are not regenerated on replace by default. You can manually edit notes on GitHub or run with <code>--notes</code>, <code>--notes-file</code>, or <code>--generate 1</code> as needed.</p><h3>Select Branch / Custom Repo</h3><pre><code>./utils/build-release.sh --branch main\n./utils/build-release.sh --repo yourname/pinballctl</code></pre><h3>Use Generated Notes</h3><pre><code>./utils/build-release.sh --generate 1</code></pre><h3>Override Notes Manually</h3><pre><code>./utils/build-release.sh --notes &quot;Maintenance release with fixes&quot;\n# or\n./utils/build-release.sh --notes-file docs/release-notes-0.1.1.md</code></pre><p>---</p><h2>Script Options (Reference)</h2><pre><code>--repo &lt;owner/repo&gt;      GitHub repository (default: auto-detect from git remote)\n--branch &lt;name&gt;          Branch to checkout before building (default: current)\n--generate &lt;0|1&gt;         Use GitHub&#x27;s --generate-notes instead of CHANGELOG (default: 0)\n--notes &quot;&lt;text&gt;&quot;         Inline release notes (overrides CHANGELOG/generate)\n--notes-file &lt;path&gt;      File for release notes (overrides CHANGELOG/generate)\n--changelog &lt;path&gt;       Changelog file to read (default: CHANGELOG.md)\n--latest &lt;0|1&gt;           Mark as latest release (default: 1)\n--prerelease &lt;0|1&gt;       Mark as prerelease (default: 1)\n--replace &lt;0|1&gt;          Overwrite existing release if it already exists (default: 0)</code></pre><p>---</p><h2>Recommended Release Workflow</h2><ol><li><strong>Branch is clean</strong> and CI is green.</li><li><strong>Bump version</strong> in <code>pyproject.toml</code>.</li><li><strong>Update <code>CHANGELOG.md</code></strong> with the new section.</li><li>Commit:</li></ol><pre><code>   git add pyproject.toml CHANGELOG.md\n   git commit -m &quot;chore(release): vX.Y.Z&quot;</code></pre><ol><li><strong>Run the script</strong>:</li></ol><pre><code>   ./utils/build-release.sh              # normal release\n   # or\n   ./utils/build-release.sh --prerelease 1  # pre-release</code></pre><ol><li>Verify the <strong>GitHub Release</strong> page shows correct notes and assets.</li></ol><p>---</p><h2>Optional: GitHub Actions (Auto on Tag)</h2><p>If you want CI to re-build and upload assets on tag push, add a workflow like:</p><pre><code>name: Build &amp; Release on Tag\n\non:\n  push:\n    tags:\n      - &quot;v*&quot;\n\njobs:\n  build-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: &quot;3.11&quot;\n      - run: python -m pip install --upgrade pip build\n      - run: python -m build\n      - uses: softprops/action-gh-release@v2\n        with:\n          files: |\n            dist/*.whl\n            dist/*.tar.gz\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</code></pre><p>&gt; This complements (but doesn’t replace) the local maintainer script.</p><p>---</p><h2>Licensing Note (Setuptools Deprecation)</h2><p>Setuptools warns that TOML table form for <code>project.license</code> is deprecated. Prefer SPDX string + license files:</p><pre><code>[project]\nlicense = &quot;MIT&quot;  # SPDX identifier\n\n[tool.setuptools]\nlicense-files = [&quot;LICENSE&quot;, &quot;COPYING&quot;, &quot;LICENSE.*&quot;]</code></pre><p>Deadline per warning: <strong>2026-02-18</strong>.</p><p>---</p><h2>Troubleshooting</h2><ul><li><strong>Release exists</strong></li><li>Default: script fails.</li><li>Use <code>--replace 1</code> to overwrite assets (uses <code>gh release upload --clobber</code>).</li></ul><ul><li><strong>422: Latest release cannot be draft or prerelease</strong></li><li>GitHub rule. Use <code>--prerelease 1</code> and the script will auto-disable <code>--latest</code>.</li></ul><ul><li><strong><code>gh</code> not authenticated</strong></li><li>Run <code>gh auth login</code> or export <code>GH_TOKEN</code> / <code>GITHUB_TOKEN</code>.</li></ul><ul><li><strong>Version parse failed</strong></li><li>Ensure <code>pyproject.toml</code> has <code>[project].version = &quot;X.Y.Z&quot;</code>.</li><li>Python &lt; 3.11? The script falls back to <code>grep+sed</code>, but 3.11+ is recommended.</li></ul><ul><li><strong>Missing assets in release</strong></li><li>Verify <code>dist/</code> contains <code>.whl</code> and <code>.tar.gz</code> after <code>python -m build</code>.</li><li>Re-run with <code>--replace 1</code> to upload artifacts again.</li></ul><p>---</p><h2>Future: PyPI Publishing (Optional)</h2><p>When ready to push public releases to PyPI, add to your workflow or a separate script:</p><pre><code>python -m pip install --upgrade twine\npython -m twine upload dist/*  # requires a PYPI token</code></pre><p>Store secrets in GitHub as <code>PYPI_TOKEN</code> and use it in CI with <code>twine</code>.</p><p>---</p><p><strong>Maintainer contact:</strong> (add your details here)</p>","plain":"MAINTAINER GUIDE — pinballctl This document is for project maintainers. It covers versioning, building, and publishing releases using the maintainer-only script: utils/build-release.sh. --- Prerequisites GitHub CLI: gh installed and authenticated Python: 3.11+ recommended for tomllib parsing in the script Build tooling: The public CLI pinballctl intentionally contains no release/publish commands. Release operations are maintainer-only via the script. --- Versioning & Changelog Follow Semantic Versioning: MAJOR.MINOR.PATCH e.g., 0.1.1 . Bump the version in pyproject.toml: Update with a new section at the top: The release script extracts the section matching the exact version ## 0.1.1, ## v0.1.1, or ## 0.1.1 . If not found, it can use --generate 1 or fallback --notes/--notes-file. --- Building & Releasing The maintainer script builds sdist + wheel, tags using vX.Y.Z, and creates a GitHub release. Normal Release Latest by default Uses to populate notes. Creates tag v if needed and pushes it. Creates a GitHub release and uploads artifacts. Marks as latest, unless you specify otherwise with --latest 0. Pre-release GitHub does not allow a prerelease to be marked as latest. The script auto-disables --latest when --prerelease 1 is set. Replace Existing Release Overwrite Assets If a release already exists for this tag, the default behavior is to fail safely. Pass --replace 1 to overwrite clobber the assets in-place: Notes are not regenerated on replace by default. You can manually edit notes on GitHub or run with --notes, --notes-file, or --generate 1 as needed. Select Branch / Custom Repo Use Generated Notes Override Notes Manually --- Script Options Reference --- Recommended Release Workflow Branch is clean and CI is green. Bump version in pyproject.toml. Update with the new section. Commit: Run the script: Verify the GitHub Release page shows correct notes and assets. --- Optional: GitHub Actions Auto on Tag If you want CI to re-build and upload assets on tag push, add a workflow like: This complements but doesn’t replace the local maintainer script. --- Licensing Note Setuptools Deprecation Setuptools warns that TOML table form for project.license is deprecated. Prefer SPDX string + license files: Deadline per warning: 2026-02-18. --- Troubleshooting Release exists Default: script fails. Use --replace 1 to overwrite assets uses gh release upload --clobber . 422: Latest release cannot be draft or prerelease GitHub rule. Use --prerelease 1 and the script will auto-disable --latest. gh not authenticated Run gh auth login or export GHTOKEN / GITHUBTOKEN. Version parse failed Ensure pyproject.toml has project .version = \"X.Y.Z\". Python < 3.11? The script falls back to grep+sed, but 3.11+ is recommended. Missing assets in release Verify dist/ contains .whl and .tar.gz after python -m build. Re-run with --replace 1 to upload artifacts again. --- Future: PyPI Publishing Optional When ready to push public releases to PyPI, add to your workflow or a separate script: Store secrets in GitHub as PYPITOKEN and use it in CI with twine. --- Maintainer contact: add your details here","excerpt":"MAINTAINER GUIDE — pinballctl This document is for project maintainers. It covers versioning, building, and publishing releases using the maintainer-only script: utils/build-release.sh. --- Prerequisites GitHub CLI: gh..."},{"slug":"2-technical-notes/specifications/PACKAGING","path":"2-technical-notes/specifications/PACKAGING.md","title":"In the project root:","order":10000,"html":"<h1>In the project root:</h1><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install build</code></pre><h1>2) Build the package (creates wheel + sdist in ./dist/)</h1><pre><code>python -m build</code></pre><h1>You should now have something like:</h1><p>dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz</p><p>Create a new GITHUB release with</p><p>gh release create v0.1.0 dist/*</p><h1>To upgrade using a release</h1><p>pip install --upgrade https://github.com/&lt;you&gt;/pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl pinballctl service restart all</p>","plain":"In the project root: 2 Build the package creates wheel + sdist in ./dist/ You should now have something like: dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz Create a new GITHUB release with gh release create v0.1.0 dist/ To upgrade using a release pip install --upgrade https://github.com/ /pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl pinballctl service restart all","excerpt":"In the project root: 2 Build the package creates wheel + sdist in ./dist/ You should now have something like: dist/pinballctl-0.1.0-py3-none-any.whl dist/pinballctl-0.1.0.tar.gz Create a new GITHUB release with gh..."},{"slug":"2-technical-notes/specifications/README","path":"2-technical-notes/specifications/README.md","title":"Technical Discussions","order":10000,"html":"<h1>Technical Discussions</h1><p>This section mirrors technical discussions and reference items from the repository root <code>/docs</code> folder.</p><h2>Imported Items</h2><ul><li><a href=\"#doc=2-technical-notes/specifications/SYSTEM_CONTEXT\">SYSTEM_CONTEXT</a></li><li><a href=\"#doc=2-technical-notes/specifications/MAINTAINER\">MAINTAINER</a></li><li><a href=\"#doc=2-technical-notes/specifications/PACKAGING\">PACKAGING</a></li><li><a href=\"#doc=2-technical-notes/specifications/RUNNING\">RUNNING</a></li><li><a href=\"#doc=2-technical-notes/specifications/EMULATOR\">EMULATOR</a></li><li><a href=\"#doc=2-technical-notes/specifications/ESPLink\">ESPLink</a></li><li><a href=\"#doc=2-technical-notes/specifications/LIGHTING\">LIGHTING</a></li><li><a href=\"#doc=2-technical-notes/specifications/EVENT_ENGINE\">EVENT_ENGINE</a></li><li><a href=\"#doc=2-technical-notes/specifications/RULIES\">RULIES (Imported from <code>.txt</code>)</a></li></ul><h2>Notes</h2><ul><li>These are intended to stay close to the original source content.</li><li>If root docs are updated, refresh these mirrored files.</li></ul>","plain":"Technical Discussions This section mirrors technical discussions and reference items from the repository root /docs folder. Imported Items SYSTEMCONTEXT MAINTAINER PACKAGING RUNNING EMULATOR ESPLink LIGHTING EVENTENGINE RULIES Imported from .txt Notes These are intended to stay close to the original source content. If root docs are updated, refresh these mirrored files.","excerpt":"Technical Discussions This section mirrors technical discussions and reference items from the repository root /docs folder. Imported Items SYSTEMCONTEXT MAINTAINER PACKAGING RUNNING EMULATOR ESPLink LIGHTING EVENTENGINE..."},{"slug":"2-technical-notes/specifications/RULIES","path":"2-technical-notes/specifications/RULIES.md","title":"RULIES (Imported)","order":10000,"html":"<h1>RULIES (Imported)</h1><p>_Imported from <code>/docs/RULIES.txt</code>._</p><ol><li>The rules should be in a table with each rule as a row. The event trigger and source should be displayed with an option to expand the row. This will then display below the actions associated with this rule</li></ol><ol><li>Rules can have one or more triggers. e.g. &quot;Right Flipper Presses&quot; AND &quot;In Bonus Mode&quot;</li><p>Not quite sure yet how we work this on the ESP. I guess some events will remain until cancelled.   We will worry about the ESP side later.</p></ol><ol><li>I would like to be able to &quot;tag&quot; rules. This should be a field that can take multiple values. e.g. Flippers, Lower Table. The interface should have an option to filter the rules by these tags. This will help with organising the rules. Tags should also be assigned a colour. The colour will display as a left border on each table row so scanning down the list will be easier</li></ol><ol><li>The trigger should allow for the selection of the hardware &quot;Friendly Name&quot; e.g. Left Flipper Button&quot; once selected the available events should be displayed e.g. PRESSED, DOUBLE PRESSED, RELEASED etc. We will need to maintain a mapping of all the Functions and what events they can have. Please populate as many as you can think off. e.g. Accelerometer -&gt; LIFTED</li><p>Functions will also have configuration options which could be the ms, angle etc. We will also need to allow the selection of a None hardware event, these could be triggered by gameplay such as &quot;X Minutes Remaining&quot;</p></ol><ol><li>The actions will also need to be specific to the target event and can target hardware items or manually trigger an event. Examples:</li></ol><p>When left flipper pressed: RGB Strip, light 2 red Coil 1, Pulse and Hold</p><p>When left flipper released Coil 1, Off</p><p>We need a mapping of all the combinations, events and the configuration options available.</p>","plain":"RULIES Imported Imported from /docs/RULIES.txt. The rules should be in a table with each rule as a row. The event trigger and source should be displayed with an option to expand the row. This will then display below the actions associated with this rule Rules can have one or more triggers. e.g. \"Right Flipper Presses\" AND \"In Bonus Mode\" Not quite sure yet how we work this on the ESP. I guess some events will remain until cancelled. We will worry about the ESP side later. I would like to be able to \"tag\" rules. This should be a field that can take multiple values. e.g. Flippers, Lower Table. The interface should have an option to filter the rules by these tags. This will help with organising the rules. Tags should also be assigned a colour. The colour will display as a left border on each table row so scanning down the list will be easier The trigger should allow for the selection of the hardware \"Friendly Name\" e.g. Left Flipper Button\" once selected the available events should be displayed e.g. PRESSED, DOUBLE PRESSED, RELEASED etc. We will need to maintain a mapping of all the Functions and what events they can have. Please populate as many as you can think off. e.g. Accelerometer -> LIFTED Functions will also have configuration options which could be the ms, angle etc. We will also need to allow the selection of a None hardware event, these could be triggered by gameplay such as \"X Minutes Remaining\" The actions will also need to be specific to the target event and can target hardware items or manually trigger an event. Examples: When left flipper pressed: RGB Strip, light 2 red Coil 1, Pulse and Hold When left flipper released Coil 1, Off We need a mapping of all the combinations, events and the configuration options available.","excerpt":"RULIES Imported Imported from /docs/RULIES.txt. The rules should be in a table with each rule as a row. The event trigger and source should be displayed with an option to expand the row. This will then display below the..."},{"slug":"2-technical-notes/specifications/RUNNING","path":"2-technical-notes/specifications/RUNNING.md","title":"Running pinballctl","order":10000,"html":"<h1>Running pinballctl</h1><p>This guide covers the supported ways to run the project:</p><ul><li>Local development (live/editable)</li><li>Local install from a wheel (no source checkout)</li><li>Install from a GitHub Release (3rd party style)</li><li>(Future) Install from PyPI</li><li>Managing services (systemd)</li><li>Upgrading &amp; uninstalling</li><li>Troubleshooting</li></ul><p>---</p><h2>Terminology</h2><ul><li><strong>venv</strong>: A per-project, isolated Python environment (recommended for everything).</li><li><strong>Editable install</strong> (<code>pip install -e .</code>): Runs your code “live” from the source folder—perfect for development.</li><li><strong>Wheel</strong> (<code>.whl</code>): A built package you can install without having the source repository.</li></ul><p>---</p><h2>1) Local Development (editable, “live”)</h2><p>Best while you’re coding and testing changes.</p><pre><code># From the project root (where pyproject.toml lives)\npython -m venv .venv\nsource .venv/bin/activate\npip install -e .\n\n# Run the app/bridge directly\npinballctl --version\npinballctl web --host 0.0.0.0 --port 5000\npinballctl bridge --port /dev/ttyUSB0 --baud 115200</code></pre><p><strong>What this does</strong></p><ul><li>Installs an import link into <code>.venv</code> so edits to <code>src/pinballctl/...</code> take effect immediately—no rebuild needed.</li><li>Installs the <code>pinballctl</code> CLI into <code>.venv/bin</code>.</li></ul><p><strong>When to use</strong></p><ul><li>Daily development, quick iterations, working on features/bugfixes.</li></ul><p>---</p><h2>1b) Local Development + Services</h2><p>You can also run your <strong>dev build</strong> under systemd:</p><pre><code># With the venv activated (created as above)\npinballctl service install                # renders venv-aware units, installs, enables, starts\npinballctl status                         # shows web/bridge states, Wi-Fi SSID/IP, ESP ports</code></pre><ul><li>The installer prefers your current <code>.venv/bin</code> so services use the dev environment.</li><li>When you change code, just restart services:</li></ul><pre><code>  pinballctl service restart all</code></pre><p><strong>Great for</strong></p><ul><li>Testing real boot/lifecycle behavior with systemd, logs, restarts, etc.</li></ul><p>---</p><h2>2) Local Install from a Wheel (no source on target)</h2><p>Package once, install anywhere—like a user would.</p><pre><code># On your dev machine (build once)\npython -m venv .venv\nsource .venv/bin/activate\npip install build\npython -m build\n# -&gt; dist/pinballctl-&lt;ver&gt;-py3-none-any.whl\n\n# On the target (e.g., Pi)\npython -m venv .venv\nsource .venv/bin/activate\npip install /path/to/dist/pinballctl-&lt;ver&gt;-py3-none-any.whl\n\n# Optional services\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>You want a clean installation without the source tree on the target machine.</li></ul><p>---</p><h2>3) Install from a GitHub Release (3rd party style)</h2><p>After you publish a Release with attached artifacts:</p><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install https://github.com/&lt;you&gt;/pinballctl/releases/download/vX.Y.Z/pinballctl-X.Y.Z-py3-none-any.whl\n\n# Optional services\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>Treat GitHub Releases as your “package registry.”</li><li>Ideal for testers or other machines where you don’t want to build locally.</li></ul><p>---</p><h2>4) (Future) Install from PyPI</h2><p>Once you publish:</p><pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install pinballctl\n\npinballctl service install\npinballctl service start all\npinballctl status</code></pre><p><strong>When to use</strong></p><ul><li>Public distribution with the simplest installation UX.</li></ul><p>---</p><h2>Service Management (systemd)</h2><p>All via the CLI:</p><pre><code># Install/uninstall units (venv-aware)\npinballctl service install\npinballctl service uninstall\n\n# Control services\npinballctl service start|stop|restart web\npinballctl service start|stop|restart bridge\npinballctl service restart all\n\n# Status (services, SSID/IP, ESP ports)\npinballctl status</code></pre><p><strong>What service install does</strong></p><ul><li>Detects your <code>.venv/bin</code> and uses it for <code>ExecStart</code>.</li><li>Creates a default <code>gunicorn.conf.py</code> in the working directory if missing.</li><li>Copies rendered units to <code>/etc/systemd/system/</code>, runs daemon-reload, enables, and starts services.</li></ul><p>---</p><h2>Upgrading</h2><p><strong>Editable (dev) install</strong></p><pre><code># You’re running from source. Just edit files.\n# If dependencies changed:\npip install -e .\npinballctl service restart all</code></pre><p><strong>Wheel / Release / PyPI</strong></p><pre><code># Upgrade within the same venv\npip install --upgrade &lt;wheel-or-package&gt;\npinballctl service restart all</code></pre><p>Examples:</p><pre><code>pip install --upgrade pinballctl\n# or from a new release:\npip install --upgrade https://github.com/&lt;you&gt;/pinballctl/releases/download/v0.2.0/pinballctl-0.2.0-py3-none-any.whl</code></pre><p><em>Tip:</em> bump the version in <code>pyproject.toml</code> for each release to avoid cache confusion. To reinstall the same version: <code>pip install --force-reinstall --no-deps &lt;wheel-or-package&gt;</code>.</p><p>---</p><h2>Uninstalling</h2><pre><code># Stop and remove services\npinballctl service uninstall\n\n# Remove the package from the active venv\npip uninstall pinballctl</code></pre><p>---</p><h2>Troubleshooting</h2><p><strong><code>zsh: command not found: pinballctl</code></strong></p><ul><li>You’re not in the venv or it’s not installed.</li><p>Activate and install:</p></ul><pre><code>  source .venv/bin/activate\n  pip install -e .    # or pip install pinballctl / &lt;wheel&gt;</code></pre><p>Or run explicitly: <code>./.venv/bin/pinballctl</code>.</p><p><strong>Services don’t start</strong></p><ul><li>Check status/logs:</li></ul><pre><code>  pinballctl status\n  journalctl -u pinballctl-web -e --no-pager\n  journalctl -u pinballctl-bridge -e --no-pager</code></pre><ul><li>Ensure <code>gunicorn</code> is installed in the same venv used by the services:</li></ul><pre><code>  . .venv/bin/activate &amp;&amp; pip install gunicorn</code></pre><ul><li>Reinstall units to point at the right venv:</li></ul><pre><code>  pinballctl service install</code></pre><p><strong>ESP not detected</strong></p><ul><li><code>pinballctl status</code> lists <code>/dev/ttyUSB<em></code> and <code>/dev/ttyACM</em></code>.</li><p>Check permissions: add your user to the <code>dialout</code> group (Debian/RPi OS):</p></ul><pre><code>  sudo usermod -a -G dialout $USER\n  newgrp dialout</code></pre><p>Then try <code>pinballctl bridge --port /dev/ttyUSB0</code>.</p><p><strong>Network info missing</strong></p><ul><li><code>status</code> uses <code>iwgetid</code>/<code>nmcli</code> and <code>hostname -I</code>. Install tools if needed:</li></ul><pre><code>  sudo apt install wireless-tools network-manager</code></pre><p>---</p><h2>Quick decision table</h2><p>| Goal | Best Method | |------|-------------| | Hack on code &amp; test instantly | <strong>Editable dev</strong> (<code>pip install -e .</code>) | | Deploy to a Pi with no source | <strong>Wheel install</strong> (local file or GitHub Release) | | Public distribution | <strong>PyPI</strong> | | Run as services | <code>pinballctl service install</code> + <code>pinballctl service start all</code> | | Check everything | <code>pinballctl status</code> |</p>","plain":"Running pinballctl This guide covers the supported ways to run the project: Local development live/editable Local install from a wheel no source checkout Install from a GitHub Release 3rd party style Future Install from PyPI Managing services systemd Upgrading & uninstalling Troubleshooting --- Terminology venv: A per-project, isolated Python environment recommended for everything . Editable install pip install -e . : Runs your code “live” from the source folder—perfect for development. Wheel .whl : A built package you can install without having the source repository. --- 1 Local Development editable, “live” Best while you’re coding and testing changes. What this does Installs an import link into .venv so edits to src/pinballctl/... take effect immediately—no rebuild needed. Installs the pinballctl CLI into .venv/bin. When to use Daily development, quick iterations, working on features/bugfixes. --- 1b Local Development + Services You can also run your dev build under systemd: The installer prefers your current .venv/bin so services use the dev environment. When you change code, just restart services: Great for Testing real boot/lifecycle behavior with systemd, logs, restarts, etc. --- 2 Local Install from a Wheel no source on target Package once, install anywhere—like a user would. When to use You want a clean installation without the source tree on the target machine. --- 3 Install from a GitHub Release 3rd party style After you publish a Release with attached artifacts: When to use Treat GitHub Releases as your “package registry.” Ideal for testers or other machines where you don’t want to build locally. --- 4 Future Install from PyPI Once you publish: When to use Public distribution with the simplest installation UX. --- Service Management systemd All via the CLI: What service install does Detects your .venv/bin and uses it for ExecStart. Creates a default gunicorn.conf.py in the working directory if missing. Copies rendered units to /etc/systemd/system/, runs daemon-reload, enables, and starts services. --- Upgrading Editable dev install Wheel / Release / PyPI Examples: Tip: bump the version in pyproject.toml for each release to avoid cache confusion. To reinstall the same version: pip install --force-reinstall --no-deps . --- Uninstalling --- Troubleshooting zsh: command not found: pinballctl You’re not in the venv or it’s not installed. Activate and install: Or run explicitly: ./.venv/bin/pinballctl. Services don’t start Check status/logs: Ensure gunicorn is installed in the same venv used by the services: Reinstall units to point at the right venv: ESP not detected pinballctl status lists /dev/ttyUSB and /dev/ttyACM. Check permissions: add your user to the dialout group Debian/RPi OS : Then try pinballctl bridge --port /dev/ttyUSB0. Network info missing status uses iwgetid/nmcli and hostname -I. Install tools if needed: --- Quick decision table | Goal | Best Method | |------|-------------| | Hack on code & test instantly | Editable dev pip install -e . | | Deploy to a Pi with no source | Wheel install local file or GitHub Release | | Public distribution | PyPI | | Run as services | pinballctl service install + pinballctl service start all | | Check everything | pinballctl status |","excerpt":"Running pinballctl This guide covers the supported ways to run the project: Local development live/editable Local install from a wheel no source checkout Install from a GitHub Release 3rd party style Future Install from..."},{"slug":"2-technical-notes/specifications/SYSTEM_CONTEXT","path":"2-technical-notes/specifications/SYSTEM_CONTEXT.md","title":"SYSTEM CONTEXT","order":10000,"html":"<h1>SYSTEM_CONTEXT</h1><h2>1. High-level architecture (ESP vs Pi responsibilities)</h2><ul><li>ESP32-S3 firmware streams hardware pin data over serial and emits periodic <code>PING</code> frames.</li><li>ESP32-S3 firmware responds to commands: <code>HELLO</code>, <code>GET_INFO</code>, <code>GET_HW</code>, and <code>SYNC_TIME</code>.</li><li>Raspberry Pi runs a bridge daemon that reads framed serial messages, logs them, and writes hardware snapshots to <code>src/instance/hardware/discovered.json</code>.</li><li>Raspberry Pi exposes a Flask-based UI and API; hardware UI reads <code>/api/hardware/pins</code> and <code>/api/hardware/reload</code>.</li><li>Bridge state (port, firmware, chip, time sync) is persisted in <code>src/instance/bridge_state.json</code>.</li></ul><h2>2. Communication model (protocol shape, framing, direction)</h2><ul><li>ESP -&gt; Pi uses length-prefixed frames: 4-byte big-endian length header + JSON payload (<code>writeFramed</code>).</li><li>Pi -&gt; ESP uses newline-delimited JSON (<code>to_line</code> in <code>bridge/protocol.py</code>).</li><li>Messages are JSON objects with a <code>t</code> field for event type (e.g., <code>INFO</code>, <code>PING</code>, <code>HW_BEGIN</code>, <code>HW_PIN</code>, <code>HW_END</code>, <code>TIME</code>).</li><li>HW discovery is streamed with <code>HW_STATUS</code> + <code>HW_BEGIN</code> + multiple <code>HW_PIN</code> + <code>HW_END</code>.</li><li>Firmware emits <code>HW_PROBE</code> before probing a GPIO when probing is enabled.</li><li>Bridge processes frames with <code>_read_frame</code> and decodes JSON.</li><li>Bridge queues outbound commands via <code>src/instance/bridge_commands.json</code> and sends them over serial.</li></ul><h2>3. Hardware interaction model</h2><ul><li>ESP firmware maintains a static <code>PIN_TABLE</code> describing pins and metadata (<code>reported</code>, <code>notes</code>, <code>safe</code>).</li><li>Pins with <code>safe=false</code> are never probed.</li><li>Probing (when enabled) is input-only: <code>pinMode(INPUT)</code> + <code>digitalRead()</code>.</li><li>GPIO probing is gated by <code>ALLOW_GPIO_PROBE</code> in firmware.</li><li>Hardware discovery is non-blocking and paced (<code>serviceHardwareStream</code>).</li><li>Pin state is included in <code>HW_PIN</code> payload only when probing occurs.</li></ul><h2>4. Known constraints explicitly visible in code</h2><ul><li>Hardware stream timeout cap: <code>HW_STREAM_TIMEOUT_MS = 8000</code>.</li><li>Serial framing: max frame size limited by <code>TX_FRAME_MAX</code> (512 bytes in firmware).</li><li>TX queue depth: <code>TX_QUEUE_MAX = 4</code> frames in firmware.</li><li>Bridge read resync: resets input buffer when header/body timeouts occur.</li><li>Bridge logs only raw RX lines at DEBUG level (no parsed JSON).</li><li>Hardware snapshot is stored at <code>src/instance/hardware/discovered.json</code>.</li><li>Hardware UI uses <code>reported</code> and <code>notes</code> fields to display pin notes.</li></ul><h2>5. Areas of uncertainty / risk (UNKNOWN)</h2><ul><li>UNKNOWN: Which GPIOs are truly safe to probe for a specific ESP32-S3-DevKitC-1 module beyond the <code>PIN_TABLE</code> defaults.</li><li>UNKNOWN: Whether USB-CDC or other serial transport variations affect framing reliability.</li><li>UNKNOWN: Any external expansion board detection mechanisms beyond GPIO probing (not visible in code).</li></ul><h2>6. Modules and UI functionality</h2><ul><li>Dashboard UI: Wi‑Fi status (interface/connected/SSID/IP/signal), bridge status (status/via/PID), uptime (since/duration/seconds), ESP32 info (firmware/chip/time/connected/time sync), dependencies list.</li><li>Logs UI: source selection (web combined/error/access/bridge), line count, keyword filter, refresh/clear/purge, tail toggle, log viewport.</li><li>Hardware UI: reload pins, save mapping, table of UID/board/type/notes/channel/state/friendly/function/purpose.</li><li>ESPLink UI: device selection, status/firmware display, refresh/reboot/sync time, bridge start/stop/restart, local firmware list, upload console.</li><li>Firmware UI: list available versions with source selection (default/custom URL), load remote, remove all local versions.</li><li>Settings UI: project name, admin username/password, remote firmware URL, log level, export project bundle, import project bundle.</li><li>Wi‑Fi UI: current status (SSID/IP/status/connected), update settings (SSID/password), save.</li><li>Playfield UI: layout table, size/ratio options, auto layout/clear/save layout, component list (buttons/LEDs/other), component settings (appearance/color/size/key bindings/remove).</li><li>Rules UI: add/save rules, tag filter, rules table (name/tags/triggers/actions), editor panes for triggers/actions.</li></ul><h2>7. Pin mapping goals and UX principles (user-provided)</h2><ul><li>Target users may be non-technical; UI should avoid GPIO jargon where possible.</li><li>Mapping should guide users from unknown hardware to identified device via simple choices.</li><li>Mapping must be safe: ESP firmware must never drive/probe unsafe pins; mapping cannot override safe=false.</li><li>UI should distinguish discovered pins, mapped devices, and active configuration.</li></ul><h2>8. Pin mapping data model (proposed minimal shape; user-provided)</h2><ul><li>A pin is identified by stable <code>uid</code> from firmware (preferred key).</li><li>Mapping is stored on the Pi (not in firmware) and can be applied/config-pushed to ESP later.</li><li>Each mapping record contains:</li><li><code>uid</code>: string (from HW_PIN).</li><li><code>gpio</code>: number|null (optional convenience; do not rely on it for uniqueness).</li><li><code>device_type</code>: enum (e.g., push_button, led_strip, coil, i2c_device, switch_matrix).</li><li><code>label</code>: human-friendly name.</li><li><code>config</code>: object keyed by type.</li><li><code>enabled</code>: bool.</li><li><code>created_at</code>, <code>updated_at</code>: timestamps (optional).</li><li>Example mapping JSON: UNKNOWN (not provided).</li></ul><h2>9. Pin mapping invariants (non-negotiable rules; user-provided)</h2><ul><li>Mapping must never assign a device to a pin where <code>safe=false</code>.</li><li>A <code>uid</code> can map to at most one device at a time (no duplicates).</li><li>UI must prevent conflicting assignments (e.g., two devices on the same <code>uid</code>).</li><li>Reload pins updates discovery state but must not destroy mappings:</li><li>If a mapped <code>uid</code> disappears, mapping is kept but flagged &quot;missing&quot;.</li><li>If a discovered <code>uid</code> is new, it appears as &quot;unmapped&quot;.</li><li>Mapping changes should be atomic (save either succeeds fully or not at all).</li><li>UI should support an Apply/Deploy step separately from Edit mapping.</li></ul>","plain":"SYSTEMCONTEXT High-level architecture ESP vs Pi responsibilities ESP32-S3 firmware streams hardware pin data over serial and emits periodic PING frames. ESP32-S3 firmware responds to commands: HELLO, GETINFO, GETHW, and SYNCTIME. Raspberry Pi runs a bridge daemon that reads framed serial messages, logs them, and writes hardware snapshots to src/instance/hardware/discovered.json. Raspberry Pi exposes a Flask-based UI and API; hardware UI reads /api/hardware/pins and /api/hardware/reload. Bridge state port, firmware, chip, time sync is persisted in src/instance/bridgestate.json. Communication model protocol shape, framing, direction ESP -> Pi uses length-prefixed frames: 4-byte big-endian length header + JSON payload writeFramed . Pi -> ESP uses newline-delimited JSON toline in bridge/protocol.py . Messages are JSON objects with a t field for event type e.g., INFO, PING, HWBEGIN, HWPIN, HWEND, TIME . HW discovery is streamed with HWSTATUS + HWBEGIN + multiple HWPIN + HWEND. Firmware emits HWPROBE before probing a GPIO when probing is enabled. Bridge processes frames with readframe and decodes JSON. Bridge queues outbound commands via src/instance/bridgecommands.json and sends them over serial. Hardware interaction model ESP firmware maintains a static PINTABLE describing pins and metadata reported, notes, safe . Pins with safe=false are never probed. Probing when enabled is input-only: pinMode INPUT + digitalRead . GPIO probing is gated by ALLOWGPIOPROBE in firmware. Hardware discovery is non-blocking and paced serviceHardwareStream . Pin state is included in HWPIN payload only when probing occurs. Known constraints explicitly visible in code Hardware stream timeout cap: HWSTREAMTIMEOUTMS = 8000. Serial framing: max frame size limited by TXFRAMEMAX 512 bytes in firmware . TX queue depth: TXQUEUEMAX = 4 frames in firmware. Bridge read resync: resets input buffer when header/body timeouts occur. Bridge logs only raw RX lines at DEBUG level no parsed JSON . Hardware snapshot is stored at src/instance/hardware/discovered.json. Hardware UI uses reported and notes fields to display pin notes. Areas of uncertainty / risk UNKNOWN UNKNOWN: Which GPIOs are truly safe to probe for a specific ESP32-S3-DevKitC-1 module beyond the PINTABLE defaults. UNKNOWN: Whether USB-CDC or other serial transport variations affect framing reliability. UNKNOWN: Any external expansion board detection mechanisms beyond GPIO probing not visible in code . Modules and UI functionality Dashboard UI: Wi‑Fi status interface/connected/SSID/IP/signal , bridge status status/via/PID , uptime since/duration/seconds , ESP32 info firmware/chip/time/connected/time sync , dependencies list. Logs UI: source selection web combined/error/access/bridge , line count, keyword filter, refresh/clear/purge, tail toggle, log viewport. Hardware UI: reload pins, save mapping, table of UID/board/type/notes/channel/state/friendly/function/purpose. ESPLink UI: device selection, status/firmware display, refresh/reboot/sync time, bridge start/stop/restart, local firmware list, upload console. Firmware UI: list available versions with source selection default/custom URL , load remote, remove all local versions. Settings UI: project name, admin username/password, remote firmware URL, log level, export project bundle, import project bundle. Wi‑Fi UI: current status SSID/IP/status/connected , update settings SSID/password , save. Playfield UI: layout table, size/ratio options, auto layout/clear/save layout, component list buttons/LEDs/other , component settings appearance/color/size/key bindings/remove . Rules UI: add/save rules, tag filter, rules table name/tags/triggers/actions , editor panes for triggers/actions. Pin mapping goals and UX principles user-provided Target users may be non-technical; UI should avoid GPIO jargon where possible. Mapping should guide users from unknown hardware to identified device via simple choices. Mapping must be safe: ESP firmware must never drive/probe unsafe pins; mapping cannot override safe=false. UI should distinguish discovered pins, mapped devices, and active configuration. Pin mapping data model proposed minimal shape; user-provided A pin is identified by stable uid from firmware preferred key . Mapping is stored on the Pi not in firmware and can be applied/config-pushed to ESP later. Each mapping record contains: uid: string from HWPIN . gpio: number|null optional convenience; do not rely on it for uniqueness . devicetype: enum e.g., pushbutton, ledstrip, coil, i2cdevice, switchmatrix . label: human-friendly name. config: object keyed by type. enabled: bool. createdat, updatedat: timestamps optional . Example mapping JSON: UNKNOWN not provided . Pin mapping invariants non-negotiable rules; user-provided Mapping must never assign a device to a pin where safe=false. A uid can map to at most one device at a time no duplicates . UI must prevent conflicting assignments e.g., two devices on the same uid . Reload pins updates discovery state but must not destroy mappings: If a mapped uid disappears, mapping is kept but flagged \"missing\". If a discovered uid is new, it appears as \"unmapped\". Mapping changes should be atomic save either succeeds fully or not at all . UI should support an Apply/Deploy step separately from Edit mapping.","excerpt":"SYSTEMCONTEXT High-level architecture ESP vs Pi responsibilities ESP32-S3 firmware streams hardware pin data over serial and emits periodic PING frames. ESP32-S3 firmware responds to commands: HELLO, GETINFO, GETHW, and..."},{"slug":"README","path":"README.md","title":"Pinball CTL Manual","order":10000,"html":"<h1>Pinball CTL Manual</h1><p>Welcome to the Pinball CTL manual.</p><p>Pinball CTL is a complete control stack for modern homebrew pinball machines. It links a Raspberry Pi web platform with an ESP32 real-time controller so you can design, configure, test, and run your machine from one system.</p><p>At a high level:</p><ul><li>The Pi side gives you the management layer: UI modules, configuration, rules, diagnostics, sync, and deployment.</li><li>The ESP side gives you the real-time layer: fast I/O, output execution, and hardware safety enforcement.</li><li>The bridge ties both together with a structured protocol so behaviour is predictable and debuggable.</li></ul><p>The result is a platform that is practical for day-to-day machine development, but also robust enough for real gameplay logic, safety-critical outputs, and long-running operation.</p><h2>Why It Is Powerful</h2><p>Pinball CTL is designed to solve real integration pain:</p><ul><li>One place to manage hardware mapping, rules, events, lighting, and runtime state.</li><li>A clear split between orchestration (Pi) and hard real-time control (ESP).</li><li>Offline-first authoring: build and adjust configuration even when hardware is not currently connected.</li><li>Visual preview workflows: test lighting and playfield behaviour before touching live machine outputs.</li><li>Confident rollout: once validated, push your authored configuration to runtime in a controlled way.</li><li>Safety-first behaviour for coils and high-power outputs.</li><li>A web-based workflow so setup and maintenance can happen without custom tooling on every client machine.</li><li>A system that can grow from simple cabinet tests to full game mode logic and scene-based lighting.</li></ul><p>In short: you can move quickly without losing control of reliability and safety.</p><h2>Manual Structure</h2><p>This manual is split into two main sections.</p><h3>1. User Guides</h3><p>User Guides are written for machine owners, operators, and builders who want clear instructions in plain English. They focus on:</p><ul><li>Getting started and first-time setup</li><li>Using the platform confidently</li><li>Common workflows and troubleshooting</li><li>Operational best practice</li></ul><p>Current entry point:</p><ul><li><a href=\"1-user-guide/getting-started.md\">Getting Started</a></li></ul><h3>2. Technical Documentation</h3><p>Technical docs are for developers and advanced maintainers. They explain how the system works and why it is designed this way, including:</p><ul><li>Architecture and component responsibilities</li><li>Bridge and protocol design</li><li>Runtime models and behaviour rules</li><li>Data formats, compilation paths, and sync lifecycle</li><li>Implementation constraints and design trade-offs</li></ul>","plain":"Pinball CTL Manual Welcome to the Pinball CTL manual. Pinball CTL is a complete control stack for modern homebrew pinball machines. It links a Raspberry Pi web platform with an ESP32 real-time controller so you can design, configure, test, and run your machine from one system. At a high level: The Pi side gives you the management layer: UI modules, configuration, rules, diagnostics, sync, and deployment. The ESP side gives you the real-time layer: fast I/O, output execution, and hardware safety enforcement. The bridge ties both together with a structured protocol so behaviour is predictable and debuggable. The result is a platform that is practical for day-to-day machine development, but also robust enough for real gameplay logic, safety-critical outputs, and long-running operation. Why It Is Powerful Pinball CTL is designed to solve real integration pain: One place to manage hardware mapping, rules, events, lighting, and runtime state. A clear split between orchestration Pi and hard real-time control ESP . Offline-first authoring: build and adjust configuration even when hardware is not currently connected. Visual preview workflows: test lighting and playfield behaviour before touching live machine outputs. Confident rollout: once validated, push your authored configuration to runtime in a controlled way. Safety-first behaviour for coils and high-power outputs. A web-based workflow so setup and maintenance can happen without custom tooling on every client machine. A system that can grow from simple cabinet tests to full game mode logic and scene-based lighting. In short: you can move quickly without losing control of reliability and safety. Manual Structure This manual is split into two main sections. User Guides User Guides are written for machine owners, operators, and builders who want clear instructions in plain English. They focus on: Getting started and first-time setup Using the platform confidently Common workflows and troubleshooting Operational best practice Current entry point: Getting Started Technical Documentation Technical docs are for developers and advanced maintainers. They explain how the system works and why it is designed this way, including: Architecture and component responsibilities Bridge and protocol design Runtime models and behaviour rules Data formats, compilation paths, and sync lifecycle Implementation constraints and design trade-offs","excerpt":"Pinball CTL Manual Welcome to the Pinball CTL manual. Pinball CTL is a complete control stack for modern homebrew pinball machines. It links a Raspberry Pi web platform with an ESP32 real-time controller so you can..."}]}</script>
  <script src="./assets/js/main.js"></script>
</body>
</html>
